{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/react-18-concurrency-and-streaming-with-rsc/","result":{"data":{"site":{"siteMetadata":{"title":"조성개발실록"}},"markdownRemark":{"id":"0106321e-2cce-52cd-aab4-f3ec91c286f0","excerpt":"2022년 3월 React 18이 발표되며 동시성 렌더링이라는 패러다임이 소개되었습니다 그리고 그 후속 마이너버전에서는 또 React Server Component가 소개되었고요 이 뒤로는 이러한 React 18의 기능을 사용한 Next.js 13 App Router…","html":"<p>2022년 3월 React 18이 발표되며 <strong>동시성 렌더링</strong>이라는 패러다임이 소개되었습니다<br>\n그리고 그 후속 마이너버전에서는 또 React Server Component가 소개되었고요<br>\n이 뒤로는 이러한 React 18의 기능을 사용한 Next.js 13 App Router가 발표되는 등 아주 SSR계의 무대를 뒤집어놓았는데요<br>\n3년이 지니난 지금 <del>뒷북이지만</del> 이 React 18 당시 어떤 일이 있었는지 대충 알아보려고 합니다</p>\n<p>이번 글에서는<br>\nReact 18 이전에는 어땠고<br>\nReact 18 어떤 일이 있었고<br>\nReact 18 이후 어떤 변화가 있었는지<br>\nServer Side Rendering 중심적으로 알아보려고 합니다</p>\n<p>어느정도 React에 대해서 아시는 분을 대상으로 씁니다</p>\n<h1 id=\"react-18-이전의-시대---csr-vs-ssr\" style=\"position:relative;\"><a href=\"#react-18-%EC%9D%B4%EC%A0%84%EC%9D%98-%EC%8B%9C%EB%8C%80---csr-vs-ssr\" aria-label=\"react 18 이전의 시대   csr vs ssr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React 18 이전의 시대 - CSR vs SSR</h1>\n<p>React 18 업데이트와 관련하여 넷플릭스 시니어분이 말아주시는 <a href=\"https://www.youtube.com/watch?v=pj5N-Khihgc&#x26;list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&#x26;index=4\">유튜브 영상</a>이 있는데 길지 않으니 한번쯤 보셔도 괜찮을 것 같구요<br>\n여기서는 React 18 이전에 CSR(Client Side Rendering)과 SSR(Server Side Rendering), 그리고 React 18 이후의 SSR에 대해 이야기합니다</p>\n<figure>\n<p><img src=\"https://i.imgur.com/D9kz0Pb.png\" alt=\"CSR\"></p>\n<figcaption>\n<p>출처: 유튜브 <a href=\"https://www.youtube.com/watch?v=pj5N-Khihgc&#x26;list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&#x26;index=5\">Streaming Server Rendering with Suspense</a></p>\n</figcaption>\n</figure>\n<p>Client Side Rendering(이하 CSR)은 전통적인 React의 렌더링 방식이라고 보시면 되는데요<br>\n브라우저는 JS를 가져오고.. 데이터를 가져다가.. 컴포넌트를 렌더링합니다<br>\n그 다음에서야 사용자는 화면을 보고 상호작용할 수 있습니다</p>\n<p>여기서 인터넷이 느리거나, JS 번들사이즈가 크거나 하는 상황을 생각해보면<br>\n<code class=\"language-text\">Load JS</code> 또는 <code class=\"language-text\">Fetch Data</code>에서 필연적으로 병목이 생기게 되고(서버까지 갔다와야 함)<br>\n그동안 유저는 빈 화면을 보며 지루하기 짝이 없는 시간을 보냅니다</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 300px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/858ae089351c3bc412de2c63ae8d5626/5a46d/image.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.69620253164557%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACqklEQVR42gGfAmD9AKCnsMDEvLq7ucXHysPEwL/Aub+/tL6+sbm5rba2qre4q7u7rKipm6eoncDCtMLDtMnJu8vLvs/Px7CrpgCBhIy3tJ/Bv7LAwcHBwbu9vrW9vbG4uKy3t6u6u6y9vayyr590X1VuUUmTjIPExrTGx7XPz7vIztKQoLYAaW18ipexuL7Ou7i1trWztrWssbGluLisu7ytvLypwsSwyLKiuoVxjVlHQC8turqovLypx8e4zc/KaYCcAGdviHmPt4ihz5mqzNDSotrb1rSzraipmq+woK6voKSpobOSf6drU3pRP11SS7u7q76/s8PEv8XGwHuJlwCPgoWyrLJqhLRzjLmQoKWVqMi3ucC1sqacmpBZYHFHV3GZiZtqSEY8ODyRkZLV1dHe3t3Fw8Xs5+C+vr8AjXx3mJGXYXutbICpaoKzboSstLvD1dLPjIuRJi9EQ1FlYFWIJylFCBEdGB4tuby82tTEzMG1/u3Yr412AHdgaXt4k1pwnGVxkVptkmR1mN/q8uLq7zs9ShcfLk5NYzQtPyYvOyEnNj1CUcXDu5+joWx1jIV7fGw6IQCYZYGni6qle6RZZYNMXYFaaITq7u5udYMoKjMvNjtBOFYpJ0QZHyksMEJQVF6LkJ4oPW4RIlAoLz13VRoAnW1plYqFv6GxeHqNUFpzb2BlmoSHPj9MlI5+Nzk8X1JcPDs4AwUPExUjMjVBNUNkYGV2ZmRdPkAzf3ESAF09QJN+W8augtC3k7Wih5GNcHyEdXeDhomMjGRndoqKlHmBgklPYVRZXGZaRDQyOYd7ZW5kZV5cFY5uGwApITh+cGXVs3/Tr3jduHjmxH/ZyIW6un6Wo3iElHh1hHFveXFuenaloG7OrGRbV1hwcnhJY5RUY0KdQUKYvWKrcYMiWQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"지루하다....\"\n        title=\"\"\n        src=\"/static/858ae089351c3bc412de2c63ae8d5626/5a46d/image.png\"\n        srcset=\"/static/858ae089351c3bc412de2c63ae8d5626/c26ae/image.png 158w,\n/static/858ae089351c3bc412de2c63ae8d5626/5a46d/image.png 300w\"\n        sizes=\"(max-width: 300px) 100vw, 300px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>그 다음은 (동시성 업데이트 이전의) Server Side Rendering(이하 SSR)을 봅시다.</p>\n<p><img src=\"https://i.imgur.com/7d6faD8.png\" alt=\"pre-react18 SSR\"></p>\n<p>먼저 서버에서 데이터를 준비(fetch)하고, 컴포넌트를 실행하며 HTML을 한 번 생성하여 브라우저에 보내줍니다.<br>\n브라우저는 HTML을 받았지만, 이건 그냥 진짜 HTML 그잡채라서 React 어플리케이션으로서의 기능이 없습니다<br>\n따라서 그 다음에는 JS를 로드하고, Hydration을 진행합니다.</p>\n<p>다시 인터넷이 느리거나 JS 번들 사이즈가 큰 상황을 생각해보면<br>\n<code class=\"language-text\">Load JS</code> 단계에서 병목이 생길 수 있지만, 적어도 유저는 <strong>화면을 볼 수는 있다</strong>는 점이 다릅니다<br>\n상호작용같은건 아직 못하겠지만요</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 225px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/48d6536815499c39d7699285d83f2800/3684f/image-1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEz0lEQVR42gHEBDv7ADM5SztBVhETGQAAAAYFCDc6PjE6QiArNiMuPR8sOx8tOiUyPyczQh4oNhohKQ4SF0NDTIp/hHhlX2JHNQAAAAAVFiQlKjYFBQUAAAAcGxsrLTUYICYbJS8mLz0qMUEqMEQIDRU6O0RGRUxRSkptYWBcTEVUPjJdQzMAaHFyKC0tBgYKAQECAAAAHiAuOUFVHCMtMDhLLTJFOT9UKSw2RUNKkYeJgHJxgG5oZE9CRzUqOSgdZ0w8ALzEuK61rIOMhExSUBUZGAwPFigrPi4zRlFZeFJbe1JffGNmdq2ipqybmYNvZ2VRSFhFOEgzJzsqIlpGOACOlqGqrKK6uqa0tKCYm41jZVkoKiMLDRAfJjc9RV5VYIJmaXennZ+jlJORe29yW01GMyRROyw/LiNJOC8AHkaJLkuBS157g4aMmpaNop2JoJiEf3tnSEg+EREQOD9Uamt4r6GhoYl9eV9OjndrXEM1VkAzTjgrMiQcAHuLpGyAn1pynW9+mmx3i2hygm5yd359dZmRg4N9bUNKWjY6TId8eqCCbzQqJ01EQ5B3aWNIPGpTSBQLBgBqZnCXk5ff29/BvsOprq97fm9hXV1ATVhATFhRWmFKU2goLz5bVVZyWU0eGyAtKi6JdW10V0l+ZFkcEQwAsJqQraekucS/ubi6yMXFwrCTtp10pJiCk4dyenVqUFZhMDhIgHNxPjAsGw0HUz4xf25ohW1gh2pdNSEXAL2SeL2umLjAx6yztbe0s7WysrKvp7KjlKqXe7aihWlmZ1pWXXBbTSUXFBQNBzQiFmBQSI94a4xuXk02KQCfjHXEubXU0+vSuKLCn3uwtLiwq6qtm4uqmIGwnoR0ZFdZRTxINy4+LicQCQcNBQA7LCSDbmKJbF1wVUcArKF57fH/4uH+vcWwtp+MybKeurWwr5uDuqWOl4l9XlZWX01CNyYdVEA1LiAbCgYCKxwVU0E3eWJTiWxdAM+1juPk8N/f+M/W6MrH2svDzcC8wr2vopeHexsdIVFWYJCAfkU1MFVBN0YxJQcBABsRDC0fFj0vI2RPRADVwqnm5/Hd3PHS0eXHyNjBv8q/t7jAsaeViYAPERk+PUWYj5WKe3t0ZmR3XlAiEgsbDgowIBkyIRc6KBwA6en95uT329bkzsLCsrGyuLCuvbSuuKuiu6eWoZSOj5SrmJipp5ibenFznYuHXUIyOCQbMSEZQS8kQS8gAO/t9+7t+uHh9NbU58jGzsW7vMC0sbmsprWilrejkq6hnW9wfp6ZolZSWHx0epeCd25VR1I8L1xIOmtaTwDz8f7k4vTX1uXPy9DKxcHFvb28t7m6sLiyoZevnY+kk4cnJymBhpmMkKSNipmimZ6rnp+hkY+BbWWYjYwA6+n65+b63d3409Tqvb3Hvb3Gu7vEtrW9rJ2VqJeNrp2WNjY4FhwkJScxNDQ+S0lRe3iBg3+IU0tLXVhZAOzs+eXk/NbY8c3N3b68v7q6wbu6wbGwuKSWkKqYj6+gmDc1OQ4TGhwfJhwgJx0gKCAiKSUlLCAfIz07QgDd3vPR0OXJyNDIwbzBuLS2srizsruopa+glZB/dGsxLSsMDRMWGyMaHScdHykeISkdICcdHSUgIilbXWrquwnzVdjehgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"모니터 보는 개\"\n        title=\"\"\n        src=\"/static/48d6536815499c39d7699285d83f2800/3684f/image-1.png\"\n        srcset=\"/static/48d6536815499c39d7699285d83f2800/c26ae/image-1.png 158w,\n/static/48d6536815499c39d7699285d83f2800/3684f/image-1.png 225w\"\n        sizes=\"(max-width: 225px) 100vw, 225px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>그래도 유저는 상호작용이 준비되는 동안 빈 화면이라도 볼 수 있고 이는 유저 경험에 크게 유리해집니다<br>\n이러한 맥락에서 영상에서는 Server Rendering을 이렇게 표현합니다</p>\n<blockquote>\n<p>Server rendering is an additional layer of optimization on top of a client rendered app.</p>\n</blockquote>\n<h2 id=\"hydration이-근데-뭔가요\" style=\"position:relative;\"><a href=\"#hydration%EC%9D%B4-%EA%B7%BC%EB%8D%B0-%EB%AD%94%EA%B0%80%EC%9A%94\" aria-label=\"hydration이 근데 뭔가요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hydration이 근데 뭔가요?</h2>\n<p>Hydration이라는 새로운 단어가 익숙하지 않으실 수 있으니 소개하고 넘어가겠습니다<br>\n저도 사실 몇번 봐서는 자꾸 헷갈렸음</p>\n<p>이 블로그 만드는데 쓰인 SSR/SSG 프레임워크인 <a href=\"https://www.gatsbyjs.com/docs/conceptual/react-hydration/\">Gatsby.js의 문서</a>에서는 Hydration을 이렇게 소개합니다</p>\n<blockquote>\n<p>Hydration is the process of using client-side JavaScript to add application state and interactivity to server-rendered HTML.</p>\n</blockquote>\n<p>그러니까 <strong>일개 HTML쪼가리를 어엿한 React Application으로 만들어주는 과정</strong>인데요<br>\n이벤트 핸들러를 붙여줘서 상호작용할 수 있게 하거나<br>\n상태나 훅 등 React 기능을 붙여주거나<br>\n등등..</p>\n<p>이런걸 하려면 그 레시피인 JavaScript가 있어야 하니<br>\n위에서도 Hydration 전에 <code class=\"language-text\">Load JS</code> 단계가 필요했던 것을 볼 수 있습니다</p>\n<h2 id=\"react-18-이전-ssr의-한계\" style=\"position:relative;\"><a href=\"#react-18-%EC%9D%B4%EC%A0%84-ssr%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"react 18 이전 ssr의 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React 18 이전 SSR의 한계?</h2>\n<p>근데 문제는 이 SSR의 전 과정이 <em>전체 어플리케이션</em>에 대해 동기적으로 일어난다는 점입니다<br>\n각 과정을 \"다같이\" 진행해야하고 먼저 끝났다고 의리없이 혼자 가는건 못합니다</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 251px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c1b23466e04f23c319b0413a7de5d822/26abe/image-2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.37974683544303%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD20lEQVR42gHQAy/8AEJRYltxf4WGjISOm2F8lGB0iXqYs3WjxnOixnehwoGmwW6XsWiNpG6Ys2iVtGyUsE9uhkZmf0lpgUFgdwBZb3d+km6doX9IT0wkFxovGxVfand+rM19q82QutmTt9KOrMRwlKlmjaZnkq5Zgp5ZbH1JaoFFaoJGaYIAXnWCdpKOepeZNT9DJhEPLh4aLB8dOCkpQjk6dH6Lo8HYgKa+ZoqgYnyMXH+URWR6d2JfcG5xPmN9TWl9AFBvg1V0jGeKolx3jCktNhoREi0cGjYhHTcjHD4jGmx3g2+cu3GFk5KRj15veUo9SGU3MWNMTThbclRfaABSdoxZfZRli6VskKg0QU8TCgwpGhgzIB00JCEvIx5APD1ifI9ua21yZ2FPVVpZJiiFKyVsOzwwQlI7MjsAWH+cXIKhXoakXYy0L0NYFQwOJRobKhwZLyUiUz45mHVuWGVxVVNYS0hIVl9jZWFpiD9BeDQwQEFQOzFVAFB2lk91kkFskj9dkjA1URsUGBsSFVdIRpRrYt6ThP6wncGrqYeJklJYYnR1freelnVaVjYoLiYgJjwtNQBBZohIbo04NVA7KT0pIzAuICA9KSji0dD/+PLbopS3g3GUjI2IiJR8d36lmJzTtrDXw8Sei5IyLjYxJyoANV5+NkZfSCQwTSMoOx0gUTQzgFBCu4l59dvTqaGcXnFwVm51dXuEiomStaWn4aSb3aup79vof3eFHh4nACpScyEnPmsPEosUCmgbGFU6NGU6NoZOQWhBOGhVUamltJqlunuBf4iLlrxvecZcU8Vsa8i8yFpfcyotOgAkP1w8QT6TRR/DbizIjjZ/YjpYOD9LNTUtHyF5XV7Rr57k18PXztC/urTPk3PMgELas2Obh1hXWGpmY24AHiMyaWA79NlM3KJe3KJs471Ho4Y2UzYxMR8gLCEgb1RJpqZ+7eTq//rg8dFq155m151o361jy7JYdG91AB4cIaWOP/nTVtaUXOGvYPnLUL6UOlcrIzIaFjMaGGwyKn1SQJ+UpOjaofTPU+SzWdmiZ+/DWta1UF5cYQAOEBKHaDrkqGTRg1jSlXvdmGWrd04yGRIdEhI6HxxXLSh2PzqMhZmpmInSg2fisWvitWHYj2K+k2RaWl4ACwwbSz8g68dC3rJI7sBO1qo7mGkxMxsUHxMTRSQgWzIsfE9LhYGaoZmk3q5X5bpT+d1K3rxGpItTYl5iAAoKFVBBIlE/HDwuGH5fIFUwHUciHzseGScWFUMmJk4sK3ZSVGJieoyCeIl+XWdjYYx6UmhdUEhKW0lHVqTPlA+GJr72AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"다같이죽어\"\n        title=\"\"\n        src=\"/static/c1b23466e04f23c319b0413a7de5d822/26abe/image-2.png\"\n        srcset=\"/static/c1b23466e04f23c319b0413a7de5d822/c26ae/image-2.png 158w,\n/static/c1b23466e04f23c319b0413a7de5d822/26abe/image-2.png 251w\"\n        sizes=\"(max-width: 251px) 100vw, 251px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>무슨 말이냐? 아래와 같은 예시를 생각해봅시다</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/75a9a5b44730ee4f6aefb590243fd8ab/a1253/image-3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.15189873417721%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQUlEQVR42m2S13KEMAxF/f8/CQwtoYalheocSwPjZXMeNNjWVUOmLMuqquq6/ha+hDzPsyzLhcwDh9u/aRrDeRxHa+15ntZj3/eiKNq2XZbFfsAlekO8eZ45/F5wnKaJiD/C+A5P+AzD4DInScIXThywpOq6TmX3B5dqFe77vnfiMAyJdJc9CH6F54V/iYTmTRAEvvgl+H7MjARMUZtXN76dOIoippemKfUzA4ZE5tPjkV9Z1xWVK5sGdDyMCstIND+9YbURfLD3JT5u2mRG45dNIAJTGBYB5TEk8iDbtm0XELvMNKM9H8eBnYRDwIknFoG2sYRATETuCeoylwJ/m7bjOKZz2sabI3F17YoLbrDICOTEhNFiNmEV6IVnXZhK0C3SV/VEYh4/EChEp3DDFP9dUuMvA5ZiyPNYdfKwT5/iPz65IyAqwRLCAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"예시 화면\"\n        title=\"\"\n        src=\"/static/75a9a5b44730ee4f6aefb590243fd8ab/f058b/image-3.png\"\n        srcset=\"/static/75a9a5b44730ee4f6aefb590243fd8ab/c26ae/image-3.png 158w,\n/static/75a9a5b44730ee4f6aefb590243fd8ab/6bdcf/image-3.png 315w,\n/static/75a9a5b44730ee4f6aefb590243fd8ab/f058b/image-3.png 630w,\n/static/75a9a5b44730ee4f6aefb590243fd8ab/a1253/image-3.png 657w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이런 화면이 있을 때, 이 네 컴포넌트들에 대해</p>\n<ol>\n<li>필요한 전체 data들을 준비</li>\n<li>모든 컴포넌트를 HTMl로 한 번 렌더링하고, 클라이언트에 한번에 전달</li>\n<li>모두에 대한 JS를 로드</li>\n<li>전체를 Hydration</li>\n</ol>\n<p>이런 식의 SSR 과정을 거치게 됩니다</p>\n<p>여기서 <code class=\"language-text\">&lt;Posts /></code>, 또는 <code class=\"language-text\">&lt;Comments /></code>가 많은 데이터를 포함한다고 생각해봅시다(보통은 그렇죠?).<br>\n그럼 <code class=\"language-text\">&lt;Nav />, &lt;Category /></code>는 이미 한참전에 준비가 끝났는데, 나머지를 기다리며 계에에속 기다려야 합니다<br>\n이건 마치 짜장면과 탕수육 세트를 시켰는데, 짜장면이 먼저 나왔어도 탕수육이랑 같이 갖다주려고 계에에속 짜장면을 냅두는 상황과 같습니다</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 175px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/dd6c455226bc816bc4f891ac86df5aa8/4edbd/image-4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 163.9240506329114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAhCAIAAABWXBxEAAAACXBIWXMAAAsTAAALEwEAmpwYAAAHQElEQVR42m1SCUwb6RWerXKoGwJ47PH4xhcmwdzELIQrAUOwA4TDxMZcxhiDDebGQDA3rImDY8xhAoTTEIebEDDZJOoqe2ilbrTbVqqqSKuNcpR0KShIqZpkl6O/2Uatqj59+vVm5v/e9+Z9D7JOLNyaWgbn+Ojs+Mjs2MjMxPj8tHV+fGiyr8vUb9BbOjv6OtsGu7tvjY7PTE4t2GbsK3dXl1bXltah9+9/fvfu/du3Drz7N37e3f3l9fbWk8ff/Pjtoydfrn9vn3355M8HBwf7u3v7e/sHHwI6+H8Bvu++/+f+7vbBwc7BwT/293f2dl/v7f2yt7e3/1/xv2TwCpxbm5t3rEPfrI3/+If1nedf7Tx/9PbNXz+U/U9A4DZo+6ftN89evn769NXTH55vPHvxl+8fj5ta54c6Htgsdy0tiwbtH7948GrjxcaLZ5t/29jafLWz9fed7W2H8sbL1w+fbumXfp+W1SPJ1KWlFlxv67BZmles+vu23t4r5aYqlTxdlp5WkJ1VIsupUhd92jU0n1/Q5CD/tPnGYPuusmdFrBjIyqnNzVSM9V6bH2pbnzLeudE6UKfu06oyUzOlYoU8W12cX15ba+zoHS9UVECPvtuwf/VDTecXau10te56+1Wzpe/G/Mj1hYGm5Zutc91XppqKJxqL87Nk1WWljZWa0jxFQYa8Vl3c066DtIaVFsvdq4PrdZ1jjQaLtrFtcGrx9qDpdk/14s3mqc7KvvLcicaiKrW6IC9XIhDwQ87HhMVejhfVqNSQqtpcqjNrW0Y1V/qVRQ1lRZq2Dv3S8DX7sM4+1jSgUxjUl8calPXKjJzUlNizYaG80NAzIbI0Sb5YAuUqdYJkWUyiRq7pThFlh5yJbG6on+vTTXco57pKi0VxmtS4iowUb9apdKEgPSY62DfQj+vr7+Xny/WDaqqq8yUZFVmSUWNrdbGK4+5foypc7KmdasyebVdJYiIF4eFBfjw2w6NCkaVLTw325LKYHE+2p/DcOahIKtZXlt+fm/r289/VaMoCPAO6GypXB2pnW+X3jCUxwTwmje3L9aKTaQFePjWZqfkJfDaDmRQVriu4DFUo5G11dUVyhbFDr29uyxPFWzurhxtzuopFleJ4no8PASW7UelkIpmAUjXS1FxBhAeLww8JiuIFQK1F8kKZPJEfXVaoGjR26rVFHcVZ10pFEX5cCpHqy/XmsDgsBpuIkrinvcKDgukUujuDxWGwOQwWlB4ZGhJ49kJkuEaRV5KXm3Ih1tJUpC8VhQf4kMg0Bo3BZZ9mUuiH4hQUIdBpDJC701meLA9IK42RJsTKxGma/LwwXpAgmt9TX9h3JVspvohxQShkCo1EBaCSaIAM9AFIBDIo6k5nQy3ypBZNXlJc3Cl3DwqBlHEp0VwnM1aLTY1qbw8OAU8EwONQABRHcJwIAYBMoLizOFAeLzDZz58A41xcYRQlGrWq0bbCLq1ksqu8Kl2QGHzGxQWLYBEcFoExOADsYY4gaEAADxquq6jPSGOS3WAYgbG4dk32cLOivyHbaixvybrI9+c6ObkCMvYQMIz7NcHCSFRYGGSfsRrLlIFe3i4uMB7BN6ulI815Jq3EpM0pS4zwZtIxMI6AEikkKvZDCRwOAI0+5Qm1JwsHy0oig4MZDHZEeESdQjTRXjDaoTSUiTPOBYJyOAAswma64xH0kIkHwGAQCT8c6kpOHm5qLMiVoSgpQSjsb1ItmjUzJk1/dcY5n9POrkAFDzjAbQTrSMCjowqMF0aEQutzE+aGqmXrCJlIpFNoN/WlywOl9mFtXc4lzMcn3dyYQUHBLs6uTDoLkIEmGDUJJVFJVBaNDtlt1oEG7ddri6dYLGcnrLle+Xixbdyg8aTTjx37LZvNyc2ROTs5A8NA81ggi0dJBCIV+E+hQg/s983NLZM3+kWJ8VJx8vlP/GODuRw69fhRJ6cTJ4ElUomUgHfYi4MdP4zgEBQAwRNRAjQxsWgx9S5N24bMXd2ddUGB/hB0HI8nOjk5A2OcnV2DznwCdgusBw64gUVB8yjiIANA9gd/umW9tTK3aLl+9WZ/a3pq4rEjx/l8PpgK3Y3p7eV78oQzIODBkGEcMBxM39E9DgHtQLa5zxcWPpudXrhhNkyPXCtRyj+CPsqV5QDBj4+fYLM4h4L4Q4txvwIHYwHT0XZXR+3M9Mza0sPhXsO81dxSV3HkN0fihcLY6KijR48xaDQPBotJZWLBbsE4MDPgPOyKYdIYiQIhND3SvXbn7n37wwXb4MpM3+RQJ1jCi3EC4QU+mGdthSoxJio0kIfFIA6fcY6FAeSEuPgytRpanp3+bHX93srq3JRlzmq6M9PHPe0efjZUnHKJ5+c/aGobMDXlSEUYF1egCUYNu2IZFKokOSka7Pb6ytK9lbW15fnb46Ylm0OZw2J5e3JTEwQ8X7+WGvVwb4Mi5zLsCh8ahsdisOdDw9OTEnhePv8Ch2gO+WwG4IkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"한번에 서빙\"\n        title=\"\"\n        src=\"/static/dd6c455226bc816bc4f891ac86df5aa8/4edbd/image-4.png\"\n        srcset=\"/static/dd6c455226bc816bc4f891ac86df5aa8/c26ae/image-4.png 158w,\n/static/dd6c455226bc816bc4f891ac86df5aa8/4edbd/image-4.png 175w\"\n        sizes=\"(max-width: 175px) 100vw, 175px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이렇게 React 18 이전의 SSR은 각 과정이 개별 컴포넌트 단위가 아닌 전체 어플리케이션(또는 더 쉽게, 페이지?) 단위로 진행되기 때문에 문제가 생기는데</p>\n<ol>\n<li><strong>fetch everything</strong> before you can <strong>show anything</strong> : 필요한 전체 데이터의 fetch를 모두 마치기 전까지 HTML을 만들어낼 수 없다\n<ul>\n<li><code class=\"language-text\">&lt;Posts /></code>의 data fetch는 오래걸리니까, 다른 부분은 준비가 되었는데도 이 데이터요청때문에 HTML 생성을 시작하지 못하는 경우가 생김</li>\n</ul>\n</li>\n<li><strong>load everything</strong> before you can <strong>hydrate anything</strong> : 전체 앱을 위한 JS를 모두 로드해야만 hydration 단계를 시작할 수 있다\n<ul>\n<li><code class=\"language-text\">&lt;Nav />, &lt;Category /></code>의 JS 로드가 먼저 끝나도 <code class=\"language-text\">&lt;Posts />, &lt;Comments /></code>의 JS 로드까지 완료되기를 기다리느라 hydration을 시작하지 못함</li>\n<li>그럼 유저는 상호작용할 수 없는 화면만을 보며 많게는 수 초를 기다리게 됨</li>\n</ul>\n</li>\n<li><strong>hydrate everything</strong> before you can <strong>interact with anything</strong> : 모든 hydration작업이 끝날 때까지 유저는 상호작용 할 수 없다\n<ul>\n<li>만약 <code class=\"language-text\">&lt;Profile></code>의 어떤 버튼을 click하고 싶더라도, <code class=\"language-text\">&lt;Profile></code>을 지나 <code class=\"language-text\">&lt;Comments></code>의 hydration까지도 기다린 다음에서야 클릭 가능</li>\n</ul>\n</li>\n</ol>\n<p>이 세 가지 문제점을 기억해두고, 이제 React 18에서 무슨 일이 일어났는지 보러갑시다</p>\n<h1 id=\"react-18---동시성-업데이트\" style=\"position:relative;\"><a href=\"#react-18---%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8\" aria-label=\"react 18   동시성 업데이트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React 18 - 동시성 업데이트</h1>\n<p><a href=\"https://ko.react.dev/blog/2022/03/29/react-v18\">React v.18.0 by The React Team</a></p>\n<p>React에서 말하는 동시성의 핵심은 <strong>렌더링이 중단 가능</strong>하다 라는 것인데</p>\n<ul>\n<li>이전에는 렌더링이 동기(Synchronous)적이어서, 어떤 컴포넌트의 렌더링을 일단 시작했다면 이게 끝나기 전까지 렌더링을 중단할 수 없었습니다</li>\n<li>반면 <strong>동시성 렌더링</strong>은, 진행중이었던 렌더링을 중지했다 재개하거나, 심지어 진행중이던 렌더링을 아예 중단할 수도 있습니다</li>\n</ul>\n<p>React 18은 이 동시성이란걸 어떻게 도달하게 한다는건지, 중요한 요소 몇 개만 개괄적으로 알아봅시다</p>\n<h2 id=\"suspense\" style=\"position:relative;\"><a href=\"#suspense\" aria-label=\"suspense permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Suspense</h2>\n<p>컴포넌트 트리의 일부가 아직 준비되지 않았다면, <code class=\"language-text\">&lt;Suspense></code>를 사용하여 로딩상태를 <em>선언적</em>으로 지정할 수 있습니다</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Suspense</span></span> <span class=\"token attr-name\">fallback</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Spinner</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Comments</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Suspense</span></span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>이 코드블록은 \"잠시만요, <code class=\"language-text\">&lt;Comments /></code>가 아직 준비중이니 대신 <code class=\"language-text\">&lt;Spinner /></code>를 드릴게요\" 정도의 의미가 됩니다</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 228px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c1b4f425036edd3e7de252c8a6b3b937/d4770/image-5.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 96.83544303797468%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAAsTAAALEwEAmpwYAAACTUlEQVR42m2TV4sqQRCF9/+/iCCivinCvgiLKCpijohids0557TmcO83216vO2zDDDPVdapOndP99uffut/vzw/xfbvdhsNhpVLp9/vz+fyZ8FxvZPR6vWw2y3a32x2NRu12O51OE5/NZoPBgPh4PK5Wq5vN5rWHBF6v18lkUqvVxuPxXC7H2+VyqVSq4/G42+0Af35+kkfzWq0mB1+vV6r6/X628/k8bWlVr9cvl8tkMmk2m+wShNR0OpXT5mEwiC2XS9iS1Gg0yD6fz8QBizwqiu8fnb++viKRiEKhiMViSqXS6/U6HI6Pjw+Qq9WKitQFCX9+5WDooZbb7aah3W5HMKvVqtfrGRg8Q51OJ8QDSeQX2sxGebZ5IylVSqUS8e12C/5JW4Ap9GwugSH8/v4eDAYtFovP59PpdBqNhplpS12Rt1gs9vu97ERIYKfTaTAYIF8sFnGLQjhHHMLox1xU6XQ6qAgpqhwOB1FCAvPDeeBNHlTxs1wuE2cQ/MNw4TPgVqtFfzyD16NzIpHIZDI44fF4CoUCnhuNRgrTBC9kVAFTRTSXwFhls9lCoVA0GhWFMAxhyBOC3V8WMOKilgRGRvyEHm+oIhKGiVSIMItM5B9WcRhTqRT2oBCHjM70F0cCnZADwVAOFofvhS7/ZzaZTGq1GuacbbPZjOCBQADPacVEXAy4wAsKNEAzeFHxAUbecDjMJCgEBj24w+LwMDxEhOAsXOA4YCp38QH+dYmZGYRbBU8RRB08Q1fiD/Dte71Kyq/ModeKSCAE+wtuXBVp8Yg8XAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"대신귀 여운알 파카를 드리겠 습니다\"\n        title=\"\"\n        src=\"/static/c1b4f425036edd3e7de252c8a6b3b937/d4770/image-5.png\"\n        srcset=\"/static/c1b4f425036edd3e7de252c8a6b3b937/c26ae/image-5.png 158w,\n/static/c1b4f425036edd3e7de252c8a6b3b937/d4770/image-5.png 228w\"\n        sizes=\"(max-width: 228px) 100vw, 228px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>구체적으로 Suspense블록 안에 뭘 넣어야 하는지, 또는 그게 완성되면 fallback을 어떻게 교체하는지, 등은 다음 글에서 알아보겠습니다</p>\n<h2 id=\"streaming\" style=\"position:relative;\"><a href=\"#streaming\" aria-label=\"streaming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Streaming</h2>\n<p>React 18에서는 새로운 서버 렌더링 API가 추가되었는데</p>\n<p><code class=\"language-text\">react-dom/server</code> 패키지는 Suspense를 사용한 스트리밍을 완전히 지원하기 위한 api를 제공합니다</p>\n<ul>\n<li><code class=\"language-text\">renderToPipeableStream</code> : Node환경</li>\n<li><code class=\"language-text\">renderToReadableStream</code> : 최신 엣지 런타임 환경(Deno, Cloudflare worker, ...)</li>\n</ul>\n<p>라고는 하는데<br>\n일단은.. \"Suspense를 사용한 스트리밍\"? 에서 이 <strong>스트리밍</strong>이 먼지 뭔저 봅시다</p>\n<h3 id=\"streaming-html\" style=\"position:relative;\"><a href=\"#streaming-html\" aria-label=\"streaming html permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Streaming HTML</h3>\n<p>HTTP/1.1 명세에 정의된 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Transfer-Encoding#chunked\"><code class=\"language-text\">Transfer-Encoding</code> HTTP 헤더</a>를 <code class=\"language-text\">chunked</code>로 지정하여 HTML을 잘라서 보낼 수 있습니다</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 261px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/229d559bf33877d666bd4ad1a21c5107/edf96/image-12.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.0506329113924%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAADnklEQVR42gGTA2z8AHBjR39yUntvTWFXOkU+KzsuHUQxF1o7FIBeKIhoNbKwoJmMd2hMI1ZFJUc5HzctGC8oFikjEyMeESskFABlWj1HPyo/PTJMSkBjSBKaZgugYA2iYwiSUwGVYRSfhl6hg0qJWQ57VRdoTCNMPCM5Lh0uKBclIBQiHRAAExEKU1NTl5qQp4Izr3INo3Abf0YSeEMYmHNQimVAcDgSl281o3AkmFwKnmkQhVoWVkAiQDQfNSsZKiQVAB0cFo+NiKmCNY5VAnhHGX9GE4FSNaSLfZJuUXA7EXU+FHtIIoBQNnQ5FYxWF5JUCZViDV5GIkQ4IDouGwCPlJWxonu2gBRwNwx5SiSril69rpaeeFV7QBaSVCybXS1xNA+IWjh9UCxZJhCDRBiudRmQYxNjTSlIOiEAsLSyvJxMnGYKg1QuspqCoH5Wo4Fdmm9GeT8Ui1UqrXhLqHFErnxPu555g0YafUQYgE0aoWYJi2IeZ1Q0AJGCaMaWLal6PLCimbeZZat2IamEUamGYndAGoZKHpdZIppfJK6AV7+dfrGDWn8+EXw+F4lEC59mEIZuRgB/Yz3CspC/u6+cbEa2ehy3fh+pczC7ileVXCp/PhCfYi7EoXaXbkyFRBSwknKmbziGPBGEQAalbwuSd04AfGhOqJ+HsoxDuX8owpA6tHUjn2Iajlchw4AtvYxbwqB+mmhGcTodcT0dj182p4Ben1cVt4EitYoslnxWAJSUjo14R7WCBqpwHsGYW9OyfM6vfK6Rb8ytgMOgb7SAQItHDolGFXo9HXQ4FIloTsWoddW4cq2PU52DagCio56OgWewfAmmZAepYRW3cyC3hUS4mHHKsIvBooLIpXm8jl6zdz+9fDeaTCKXUCCwm3CzmGqqjm/awNMApaWffndqn3QauXgDlVEQmlQUn1sollkojlcjt35DrX9Zso1zvIZdsotxt4AwxIgjtJFPinJMspqX79HuAJ6el2FeTHhfM71+DMWICKhlFI1LJYZBHZ5aGqBjGqBdHJFFH5JFCKJfA9CdHbmZVnRdP0Q1I7KYn+bB3gB4d2pLRSlfUjGfgkjJkhvBegCfXwmTVhGcXA2LSw2SWxipchTLlRHfrSahfjhZSDJQQTJSQDKefXjbtNMAQz4qTUMmUEQkg3BSwrKSw5QzyYsQ0pcS16EX0JwZ06cq3KolyZYnfV4tUUExU0Q1UUAuU0g8dGdgoYaS8ddqXjRO+x4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"자르기 짤\"\n        title=\"\"\n        src=\"/static/229d559bf33877d666bd4ad1a21c5107/edf96/image-12.png\"\n        srcset=\"/static/229d559bf33877d666bd4ad1a21c5107/c26ae/image-12.png 158w,\n/static/229d559bf33877d666bd4ad1a21c5107/edf96/image-12.png 261w\"\n        sizes=\"(max-width: 261px) 100vw, 261px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token property\">\"transfer-encoding\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"chunked\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token property\">\"vary\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Accept-Encoding\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token property\">\"content-type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"text/html; charset=utf-8\"</span></code></pre></div>\n<p>이 경우 <code class=\"language-text\">Content-Length</code>헤더는 생략되며, 브라우저는 종료 청크를 받기 전까지 연결을 끊지 않고 지속적으로 HTML 청크를 받습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/35cd05ace85b62e4856f1225e6c9841a/98b29/image-11.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.177215189873415%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAyUlEQVR42oWP0W7DIAxF8/+/t7etWtImNKIECtgmAQKtu6jtHirl6goZ8JWPm9ue6q1aIe1ZzoRvIyyBmt1wqcVdLupw9Eajv6J7GKwh717huulDuBTunn5PoKYlIIEjb/klgNufXGvxehq/fs5dJ8fBKYX2ittk/kspESELwAeinNJ/hHVdA4LXRgy9EL3Thq+8cyBsGEN+t6JtR3Eajp0Ug5vUMhPTcuzBjJhz/rhOA8boQz8TxJk2c53i/ArHGBmNaz7zn9an7udAljQCAAC/AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"HTML Streaming\"\n        title=\"\"\n        src=\"/static/35cd05ace85b62e4856f1225e6c9841a/f058b/image-11.png\"\n        srcset=\"/static/35cd05ace85b62e4856f1225e6c9841a/c26ae/image-11.png 158w,\n/static/35cd05ace85b62e4856f1225e6c9841a/6bdcf/image-11.png 315w,\n/static/35cd05ace85b62e4856f1225e6c9841a/f058b/image-11.png 630w,\n/static/35cd05ace85b62e4856f1225e6c9841a/98b29/image-11.png 937w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"streaming-ssr\" style=\"position:relative;\"><a href=\"#streaming-ssr\" aria-label=\"streaming ssr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Streaming SSR</h3>\n<p>위에서 <code class=\"language-text\">Transfer-Encoding: chunked</code>를 사용하여 브라우저에 HTML을 점진적으로 잘라 보낼 수 있다고 했는데요<br>\n이 개념 + 위에서 살펴본 <code class=\"language-text\">react-dom/server</code> 패키지의 api를 사용하여 <strong>서버 사이드 렌더링을 스트리밍</strong>할 수 있습니다<br>\n더 자세한 내용은 <a href=\"https://patterns-dev-kr.github.io/rendering-patterns/streaming-server-side-rendering/\">Streaming Server Side Rendering Pattern</a> 아티클 또는 <a href=\"https://soobing.github.io/react/html-node-streaming/\">(번역) 스트리밍 HTML과 DOM 비교 알고리즘</a> 아티클을 참고하시면 좋겠습니다</p>\n<p>중요한건 Streaming과 Suspense를 함께 사용할 때인데<br>\n서버에서 렌더링하다 Suspense를 만나면, fallback을 대신 가져간다고 했습니다<br>\n이 때, Suspense가 끝날 때까지 Streaming은 아직 닫히지 않습니다<br>\n이후 기다리던 Suspense가 끝나고 HTML이 도착하면, 이것이 fallback을 대체합니다</p>\n<p>근데 완료된 Suspense가 나중에 도착하더라도 이미 fallback이 HTML에 알박기한 상태일텐데, 어떻게 이걸 갈아끼울 수 있을까요??</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 382px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2035e921ca31848789cd8a09f3246859/77edc/image-6.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.92405063291139%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAABrUlEQVR42n1Sa3PaMBDk//+l9lvTpCUlDyixjGuMbWxiCb2fNgR6tttMyyS52dFIM7e3d7qdHA6dE8oxGazt2vABDl17/j8m1uj6HtW3kaDEamEEN/INaMGcVpfk1lmlWH2HqpslTnNnpJXCqksA3xsNhBMEnC8vp7adBGdBTTMq9r1yD/UeeVDuuecO43a9HsiK86YhWcGrZyPYx2RKKeccIdSNykoysimb2Wo3TxSjfbbkI8zrRfRtQ8tFUURRpLX+OzOn1Q9UTSPWNN4bq6UzKljtrfGuh7MaspwzQCjLkhAyDg/KBqQ0bvAc/bqb5Y8P5fwhmX5fXn1ZTb/dfv60vPma/Xx8XjzJbWWMYYzB6b0flAOUVobuxaYoVqhMYsDT/SyPUZOmOEvZtoTSgVBLaRzHdV0D/3g8DmTf9y0pbZI8ipbrNIlRdH19lW1SmlWacUKpUEpZs6c0hXIYD8sa9tzBlEaQYrubRniRQhet1Z238LcwjtcSVgoRvG9DuDSJ97bZ5OCw3SIRBI9mAozGgk286vxxyD/PCXjbSqnrveWyO7Rv+fl0fid+A0dk3Qsc+ZeXAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"HTML 갈아끼우기?\"\n        title=\"\"\n        src=\"/static/2035e921ca31848789cd8a09f3246859/77edc/image-6.png\"\n        srcset=\"/static/2035e921ca31848789cd8a09f3246859/c26ae/image-6.png 158w,\n/static/2035e921ca31848789cd8a09f3246859/6bdcf/image-6.png 315w,\n/static/2035e921ca31848789cd8a09f3246859/77edc/image-6.png 382w\"\n        sizes=\"(max-width: 382px) 100vw, 382px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>사실 React는 스트리밍 중에 완료된 Suspense 본체와 함께 작은 <code class=\"language-text\">&lt;script></code>태그를 같이 보내 HTML을 조작하고 fallback을 갈아끼우는데요<br>\n이 마법에 대해서는 다음 글에서 자세히 보려고 합니다</p>\n<h3 id=\"react-server-component\" style=\"position:relative;\"><a href=\"#react-server-component\" aria-label=\"react server component permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React Server Component</h3>\n<p>React 18의 추가 마이너 업데이트에서는 아기다리고기다리던 React Server Component(이하 RSC)가 추가되었는데요 :<br>\n<a href=\"https://ko.react.dev/reference/rsc/server-components\">React - 서버 컴포넌트</a><br>\n<a href=\"https://vercel.com/blog/understanding-react-server-components\">Vercel - What is React Server Component</a></p>\n<p>React 팀에서는 서버 컴포넌트를 이렇게 소개합니다</p>\n<blockquote>\n<p>서버 컴포넌트는 번들링 전에 클라이언트 앱이나 SSR 서버와는 분리된 환경에서 미리 렌더링되는 새로운 유형의 컴포넌트입니다</p>\n</blockquote>\n<p>여기서 \"분리된 환경\" === \"(RSC에서 말하는) 서버\" 인 셈이구요<br>\n빌드 시 한 번 실행되는 CI서버거나, 각 요청마다 실행되는 웹 서버이거나, 할 수 있습니다</p>\n<blockquote>\n<p>서버 컴포넌트는 브라우저에 전송되지 않으므로 <code class=\"language-text\">useState</code>같은 상호작용 api를 사용할 수 없습니다. 대신 <code class=\"language-text\">'use client'</code> 지시어를 사용하여 클라이언트 컴포넌트를 사용합니다.</p>\n</blockquote>\n<p>이전에는 리액트에서 \"컴포넌트\"라고 하면 종류는 하나였습니다. 클라이언트에서 렌더링되는 전통적인 그것인데<br>\n이제 <strong>서버 컴포넌트</strong>라는 새로운 종류가 생겼고, 따라서 이와 구별하기 위해 이전의 종류는 <strong>클라이언트 컴포넌트</strong>라고 부르게 됩니다<br>\n이 두 종류의 React Component에 대해서는 유우명하신 React Maintainer이신 Dan Abramov 선생님의 <a href=\"https://overreacted.io/the-two-reacts/\">The Two Reacts.</a> 아티클이 되게 내용이 좋습니다. 추천</p>\n<p>아무튼간에 RSC는 <strong>개별적으로</strong> 데이터를 fetch하여 완전히 서버에서 렌더링되며, 그 렌더링의 결과물인 HTML은 클라이언트 측 React 트리에 <strong>스트리밍</strong>됩니다<br>\n대신에 이 컴포넌트(JS 번들)는 클라이언트에 전달되지 않습니다. 클라이언트에 보내는 것은 단지 컴포넌트의 실행 결과물인 HTML입니다<br>\n또한 RSC는 다른 RSC 또는 RCC(클라이언트 컴포넌트)들과 섞여 React 트리 내에서 혼재할 수 있습니다.</p>\n<figure>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/615de6183ca85e89197f988ae1c51bc7/7a3d6/image-7.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.21518987341771%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAACH0lEQVR42mVSa5eaMBDd//+L+snd7em2x13tQkUQAUUIzxAkRCIQHh2Mx632fshhmNy5M3fy5LqubdtBEBwOB8/zwjCEP0mSMMa6vs+Qhg8frKRlyTjnRVEQQiil4wVPCCFVVTcXAN+yLDh/L5eUlrxiFZr16Yvr6NstSNhRFEHdLMuuZCFEXdenC0BT0zRd1+fzOUj1/ZD4WnRQq6pirMQYd103/oOn29cwDLIxqMJ5JUQbx/Gp4q0QQRBCVt6R+CJDAOJt294SGaHKOjI27jBMUpa58uzFiRVS5U4ZCDA56IBbiqIYxtqw4k9zMBzoXDSNYPFcRN8ST7lc7h/bvmniFBOSBWGqaJFp+VIoTyxkPgf+TpLv2n4AITm4OhWCSpjAh7wOW8iytO/E/4ZNxeozz4KVY7zXdQMhGL5RX7EPbjMIozj9tdhv7Ox8rh/bhjNFxoBnDM3ocdokLTCPvg/4OfZ1CD2EV9tWNeswJpJyRy7yBO9ecw+Up9qwtmT/jt03RnMIYZHWPtc2kcx+kQFtc0bIryoOr3JiUhaE0+R107ru4cxPV4Fj7vueHPNKLln1uQo1fX8pOVKCvO3PKHBlVltvFypC4XHSaJvFUtvuCDvxC3noTIes7HGpESEazs9H78dYvCXuXGbBpPVu/FBTeEhdJ1Qjh3BtJlflgnJFzx03k+MfUyd1Xso8kNkUF6tNFkRM+uO4ePEniZPiL2o9TAtZrDRkAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"React Tree of Post-React18\"\n        title=\"\"\n        src=\"/static/615de6183ca85e89197f988ae1c51bc7/f058b/image-7.png\"\n        srcset=\"/static/615de6183ca85e89197f988ae1c51bc7/c26ae/image-7.png 158w,\n/static/615de6183ca85e89197f988ae1c51bc7/6bdcf/image-7.png 315w,\n/static/615de6183ca85e89197f988ae1c51bc7/f058b/image-7.png 630w,\n/static/615de6183ca85e89197f988ae1c51bc7/40601/image-7.png 945w,\n/static/615de6183ca85e89197f988ae1c51bc7/7a3d6/image-7.png 990w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f642f548ee99b6e97457749f514bf91a/38124/image-8.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 84.81012658227847%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsTAAALEwEAmpwYAAACbElEQVR42m1T227TQBD1j/POA6j9AZ54BFGkBlQiIRWKykPtpG3iS+Lbxtf47njtxJe1zThboiRgyevZnTkzZ+eMmTAMXdf1fd/zPDAcx6Hbtm37vl+bwiZywOi7br8M6+FhkiSZTCY8z89mM2X/wFZVlbYl4L4bXS6nX0nXa5pqWVZd1zTpCxjeOI4RQrIsG4bBcdxyudRUFUoYizuJu/Jcsyx38/l8Op2KoggEDxSY7i8f27bX6zX4Vmil6zocztkbxH8PwyiJY4CxLAt5j5kzFEnJwEoIoW649lJWwLAsmxcWWZaZpgnZj2/O0A/A8jwHAHCLomhb9iszBANcoW//Gr0tcPSfhtEPnGqaNpvNRVHwg0hSAs3AVT2EFvlmwV1J7Kd8ExzafgLGGEOfoeeCIIB4np+5foZxQb053rDjS3c122Pbc3BZloDPc2waaDqdVFUFhyCBZZmU6nZbqZpO9fuX9pDPs+XJ+E0SB/Ssafv7Lxfq8zcaoyPkh/m27M4aRnNjjb8VHz6vEbdvYRe7gsiNTO2JxqbZ7nHuuEFTN+REqqGso99fv9afr6X7dw0hVU248YWHHsIwKIp8yL6rTRevg+KkMt2AhlEYNA2M4HDhKE79APi3m00KCh8Ign7Q0bMh6WVFp30aBtZT2Z8fcJaCDckkaYnzmpChLzAOvCBWw4y3DO2kosde1ABVSAUx3O17dvQqCW1a0LBT1chT3NLiyIyRtcUFYfY6NZLiGU5RD+BefbpZsB87siOkoURMJ5H1GKIpWDciBaXbHXmRCiYa/jZ6eVv5jcQfx8MIBnA+bEGIumm7vvsD2qS6md19UDUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"React Tree of Post-React18, rendered\"\n        title=\"\"\n        src=\"/static/f642f548ee99b6e97457749f514bf91a/f058b/image-8.png\"\n        srcset=\"/static/f642f548ee99b6e97457749f514bf91a/c26ae/image-8.png 158w,\n/static/f642f548ee99b6e97457749f514bf91a/6bdcf/image-8.png 315w,\n/static/f642f548ee99b6e97457749f514bf91a/f058b/image-8.png 630w,\n/static/f642f548ee99b6e97457749f514bf91a/40601/image-8.png 945w,\n/static/f642f548ee99b6e97457749f514bf91a/38124/image-8.png 953w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<figcaption>\n<p>출처 <a href=\"https://www.plasmic.app/blog/how-react-server-components-work#what-are-react-server-components\">How React server components work: an in-depth guid</a></p>\n</figcaption>\n</figure>\n<p>이를 이해하기 위해 중요한 그림이 이것인데</p>\n<ul>\n<li>RSC(오렌지색)과 RCC(파란색)은 React Tree 내에서 혼재할 수 있고</li>\n<li>RSC는 서버에서 HTML로 렌더되며</li>\n<li>그 과정에서 RCC는 placeholder(id, props 등등 참조를 남김)로 표시하고 패스</li>\n</ul>\n<p>하단 그림과 같이 한번 Server-Render된 React Tree는 직렬화(문자열로 변환)되어 브라우저에 보내지는데, 이를 <strong>RSC Payload</strong>라고 부릅니다</p>\n<p>RSC Payload에 대해 간략히 알아보기 전에, RSC의 특징을 살펴보고 지나갑시다<br>\n가장 큰 RSC의 특징은 <strong>비동기 컴포넌트</strong>가 될 수 있다는 점인데</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getFooData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">.</span>description<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이런게 가능합니다<br>\n이러면 렌더링을 비동기적으로 진행하므로,<br>\n<code class=\"language-text\">getFooData()</code>에서 Promise를 기다리기 위해 중단하고 나중에 resolve되면 다시 돌아와 렌더링을 재개할 수 있습니다.</p>\n<p>그리고 RSC는 아래와 같은 제한사항을 가집니다 :</p>\n<ul>\n<li>RCC는 RSC를 import할 수 없습니다\n<ul>\n<li>위에서 <em>RSC는 클라이언트에 전달되는 JS번들에 포함되지 않는다</em> 라고 했습니다. 클라이언트에 전달되지 않으니 RCC에서 RSC를 찾으려 해도 찾을 수가 없겠네요</li>\n</ul>\n</li>\n<li>RSC에 작성된 모든 코드는 <strong>직렬화</strong>가능해야 합니다\n<ul>\n<li><code class=\"language-text\">useEffect</code>같은 React 라이프사이클 훅은 사용할 수 없고</li>\n<li>props로 함수를 전달할 수 없습니다 (함수는 실행컨텍스트 등의 이유로 직렬화 불가)</li>\n</ul>\n</li>\n<li>WebSocket 등 지속적인 업데이트를 지원하지 않습니다(대신 클라이언트 사이드에서 구현해야 함).</li>\n</ul>\n<h4 id=\"rsc-payload\" style=\"position:relative;\"><a href=\"#rsc-payload\" aria-label=\"rsc payload permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RSC Payload?</h4>\n<blockquote>\n<p>The RSC Payload is a compact binary representation of the rendered React Server Components tree. It’s used by React on the client to update the browser’s DOM. The RSC Payload contains:</p>\n</blockquote>\n<p>RSC 페이로드는 <strong>렌더링된 React 서버 컴포넌트 트리의 압축된 바이너리 표현</strong>입니다.<br>\n클라이언트에서 React가 브라우저의 DOM을 업데이트하기 위해 사용됩니다.<br>\nRSC 페이로드에는 다음이 포함됩니다 :</p>\n<ul>\n<li>서버 컴포넌트의 렌더링 결과물</li>\n<li>클라이언트 컴포넌트가 렌더링될 위치와 해당 JS파일에 대한 참조 등을 위한 placeholder</li>\n<li>서버 컴포넌트에서 클라이언트 컴포넌트로 전달된 모든 props</li>\n</ul>\n<p>한마디로 React 컴포넌트 트리 구조가 어떻게 구성되어있는지를 나타내는 별도의 문자열 포맷입니다<br>\n앗 그런데 트리처럼 계층구조를 나타낼거면 그냥 JSON으로 하면 안될까요?<br>\n근데 JSON은 구조상 열렸으면 닫혀야 유효한데, Streaming할 때는 닫히지 않는 경우가 있으니 이에 적합하지 않습니다</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"a\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"b\"</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"b-1\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"b-2\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"baz\"</span>\n  <span class=\"token comment\">// ❌ : JSON은 중괄호 쌍이 닫혀야 함</span></code></pre></div>\n<p>대신, 대충 아래와 같이 생겨먹습니다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1:...\n4:...\n0:...\n2:...\n3:...\n5::I[\n  \"(app-pages-browser)/./src/components/RCC.tsx\",\n  [\"app/rcc-rsc/page\", \"static/chunks/app/rcc-rsc/page.js\"],\n  \"RCC\",\n];\n7:[\n  \"$\",\n  \"div\",\n  null,\n  {\n    className: \"flex flex-col border border-solid border-white p-2\",\n    children: [\n      [\"$\", \"span\", null, { children: [\"id: \", 30] }],\n      [\"$\", \"span\", null, { children: [\"userId: \", 2] }],\n      [\"$\", \"span\", null, { children: [\"title: \", \"nemo perspiciatis repellat ut dolor libero commodi blanditiis omnis\"] }],\n      [\"$\", \"span\", null, { children: [\"completed: \", true] }]\n    ]\n  }\n];</code></pre></div>\n<p>이에 대해서는 다음 편에서 자세히 알아봅니다</p>\n<h2 id=\"selective-hydration\" style=\"position:relative;\"><a href=\"#selective-hydration\" aria-label=\"selective hydration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Selective Hydration</h2>\n<p>React 18에서는 또한 <a href=\"https://github.com/reactwg/react-18/discussions/130\">Selective Hydration</a>을 지원하는데, 이는 React 18에서 도입된 새로운 Streaming 아키텍처에 포함되는 개념입니다<br>\n이는 <strong>클라이언트에 먼저 도착한 컴포넌트는 먼저 hydrate</strong>될 수 있게 구현합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/02ce64e7afb66875466da32dd8c9aa00/a1253/image-9.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.9746835443038%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAAsTAAALEwEAmpwYAAABuElEQVR42o2U2ZKCMBBF+f9PtKAKkEVAVDbZYU64JYM6D3NLUk2S7j7dCVrrugZBkKapbdun0+lyuURhFJwDz/PCMGT0fX+e5/UvWcuy9H0/jmMn9X3d1lVdPZ/Ptm2ZYMR5+UvWR7BpmfnN67L+Q9btdoM5SZIoiuB3fdfzgfVs1zkHZ+S6ruCx2UAtlIbL/X63siyr63oYBlGXTcU49ENW5HEWF4+iqqruIGpkM7Vcr1eLhylhLOvSTwPFYNMFWAit1fkgXglhnMEuiiLflGRJfs8BKTfVm4pNj5eYh4V5gw09GAo5TENZl13bTQdp6WgAhYtxpnoYhN1N/aN4ULBp+zQRFxxxwQ8nRtM0qgJk4wyDOpGWZlmxWAYPB0YcVAs25//rnGziJDiSNEv3Kr6vhOnoS3C9YcsBSChIpRv2fKnZtNuMxpm0e81Izhg0llsBEQcmOm4ImRjVOePM024inlIRCyrglWe/G0j2uInoxpnSaUxykOM4tICcXEYMRuw4jumIei4vS0cnqVVkgw0KXslAhzknDH18ko7986tiB0lYO07qSqnbb1/VbmkBqu99OoXvv4QfQlIKMDHJDC0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Selective Hydration\"\n        title=\"\"\n        src=\"/static/02ce64e7afb66875466da32dd8c9aa00/f058b/image-9.png\"\n        srcset=\"/static/02ce64e7afb66875466da32dd8c9aa00/c26ae/image-9.png 158w,\n/static/02ce64e7afb66875466da32dd8c9aa00/6bdcf/image-9.png 315w,\n/static/02ce64e7afb66875466da32dd8c9aa00/f058b/image-9.png 630w,\n/static/02ce64e7afb66875466da32dd8c9aa00/a1253/image-9.png 657w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>또한 심지어, 유저가 원하는 <strong>특정 영역을 먼저 Hydration</strong>할 수도 있습니다.<br>\n예를 들어, 유저가 <code class=\"language-text\">&lt;Nav /></code> 내의 버튼을 클릭한다면, 이 <code class=\"language-text\">&lt;Nav /></code>의 Hydration 우선순우리ㅡㄹ 높입니다.</p>\n<p>더 자세한 내용이 궁금하시다면 <a href=\"https://patterns-dev-kr.github.io/rendering-patterns/selective-hydration/\">Selective Hydration Pattern</a> 아티클 또는 <a href=\"https://github.com/reactwg/react-18/discussions/130\">New in 18: Selective Hydration</a> Github Discussion을 정독하시면 좋을 듯</p>\n<h1 id=\"post-react18의-ssr은-뭔가-다름\" style=\"position:relative;\"><a href=\"#post-react18%EC%9D%98-ssr%EC%9D%80-%EB%AD%94%EA%B0%80-%EB%8B%A4%EB%A6%84\" aria-label=\"post react18의 ssr은 뭔가 다름 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Post-React18의 SSR은 뭔가 다름</h1>\n<p>말이 길었는데요, 다시 아까 살펴봤던 React 18 이전의 SSR에서의 세 문제를 떠올려봅시다</p>\n<p>(1) <strong>fetch everything</strong> before you can <strong>show anything</strong><br>\n(2) <strong>load everything</strong> before you can <strong>hydrate anything</strong><br>\n(3) <strong>hydrate everything</strong> before you can <strong>interact with anything</strong></p>\n<p>근데 이제 React 18에서 동시성 업데이트로 바뀐 SSR은 아래와 같아집니다</p>\n<p><img src=\"https://i.imgur.com/OkKukzu.png\" alt=\"Post-React18 SSR\"></p>\n<p>이제 일은 컴포넌트별로 각자 하고, <del>MZ사원처럼</del> 먼저 끝나면 먼저 퇴근합니다</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 252px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4d05b2c0a6d14b6357de9d796adef3b9/5e02b/image-10.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 79.11392405063292%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAAsTAAALEwEAmpwYAAADKklEQVR42i1TSYjTYBjNUS8qguJBxQUH9wXxpCCIG+jBk4rbRcE5DB4EFT3NyYMIHsXbMC4HDy44zgxGnbG1dTrTpknTNE3SNt2Sppk2zdYkTUfGVxV+Avn43vve997/E+2WXi2X5WKpIpdxOm2j67iu41y+eoNYserY8ZM7dh9cuWbd6rXr9x08cunKte8zM6EflArFgigR6AayXq0xabparji2E3S9VJLavmv/6XMXvs/MDo/cOXX2/NCeA5u3Dq3dsOnm7ZF+L2woqtFuEa7l5LjcQmKeZTKgqFWqtmk+efpsz6Ej09Pk8vKyJEnRaGxs/PXdew83bhnauf9wWa70g57VMQh0pymqYxi2aRmttlpX/K578cr1oyfO1KqKaztG2/g88XlsbLy92L7/4NG2XXuFvLDUC03DJLCnUq35Xa/nBzigcC37+fMXt4ZHAIjHYpZpUilq/OUreEFTzOTk1GJT99wuOglI9Vw38ANo4zh+Key39MVatf5pYvJH5Geez/8O+yD1PR8quk63KBV0rQmwY9lEvVZHVVXU2dnIz2gMrACjQn4hdU1vak2IhC60esCaVjwWN43OfzB8CzyfoRny67ePHz9JgojN0YQkWIYxDYPP5dANL8Jer1FXkgsLEAL2ARhNA+tVdWpqmiS/aY0GVDUbWuD7CBN75rKcUquHvVDXdWyRz/FQHgY94Ac7g6m92ALL35wsTVURPoqa2uBzea/rQZpSV1ILKfAil2gkCgqrYxIcm5VLJcwBGSQAjKuCJUEMkySpwLJZUZSSySTw2AgNOY6LRiIkSRL4z/M8dGIa9gcS9EDiYLje1HFVZLnS1DSoQ6UiV+g0nc1mU6kUgSHYATJYhgUMJ/ibCr6wBN4mEklVaSAF7A91bIaNx39xHJdIJIh/lsCbckkGElyoYAK64/G4KIoUlX7/7sPv/hIYPcdFckBmMpm5ubkBWMwLkihxoCiWBk/KdkRBoNIUhCHzN2/eDg/fKcvVfhgiMIwReAHPgaIowrVtSRRpmsEDgL3wJjGXwK2Eqvn5+TwvTExMjY4+RkjwpSLLxUIhy7I0ADTzB69mGF0e95JPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"먼저 퇴근하겠습니다\"\n        title=\"\"\n        src=\"/static/4d05b2c0a6d14b6357de9d796adef3b9/5e02b/image-10.png\"\n        srcset=\"/static/4d05b2c0a6d14b6357de9d796adef3b9/c26ae/image-10.png 158w,\n/static/4d05b2c0a6d14b6357de9d796adef3b9/5e02b/image-10.png 252w\"\n        sizes=\"(max-width: 252px) 100vw, 252px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>그 덕분에 위 세 가지 문제를 해결하게 되는데:<br>\n(1) Suspense 또는 RSC 등 비동기 렌더링으로, <code class=\"language-text\">Fetch Data</code> 단계에서 block되지 않고 각자 진행<br>\n(2) Streaming SSR을 통해, <code class=\"language-text\">Render as HTML</code>이 끝나는 대로 브라우저에 전달하고 Hydration을 진행<br>\n(3) Selective Hydration으로 개별 컴포넌트에 대한 Hydration을 먼저 완료</p>\n<p>이처럼 서버 사이드 렌더링에서 <strong>점진적 렌더링</strong>을 가능케 하여, TTFB(Time To First Byte) 단축 등 성능 상의 이점을 제공합니다</p>\n<h1 id=\"react-18이-가져온-변화--nextjs-13-app-router\" style=\"position:relative;\"><a href=\"#react-18%EC%9D%B4-%EA%B0%80%EC%A0%B8%EC%98%A8-%EB%B3%80%ED%99%94--nextjs-13-app-router\" aria-label=\"react 18이 가져온 변화  nextjs 13 app router permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React 18이 가져온 변화 : Next.js 13 App Router</h1>\n<p>React 18이 공개되고 약 7개월 후, 대표적인 SSR 프레임워크인 Next.js는 <a href=\"https://nextjs.org/blog/next-13#new-app-directory-beta\">13버전</a>을 발표했는데<br>\n이 업데이트에서는 기존 Pages Router와 다른, <strong>App Router</strong>라는 아예 새로운 패러다임이 등장해버렸습니다</p>\n<p>이전의 Next.js Pages Router는 SSR을 지원하여 서버에서 초기 데이터를 로드하고, 미리 HTML을 준비하여 브라우저에 보낼 수 있게 했습니다<br>\n그러나 이 \"서버\"에 접근하려면 다음 세 가지 메서드를 통해서만 가능했습니다 : <code class=\"language-text\">getStaticProps, getStaticPaths, getServerSideProps</code></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 267px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6337a2812f30b839cc498809f0d9e0a2/19e8f/image-13.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.88607594936708%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsTAAALEwEAmpwYAAADMElEQVR42hWS62/aBhTF/edUWqq0y7JCUsqWtF22aepSLQkoaTOSUvLgZRiM99OEYuMHAdtgYxtsTBLwMxmPbmrXD9W0SpGm/Ufzju6XK50r/e7RAVaW7jxYXnjstNF0k6JaLM+DwePTg50OAcksxuDpAU9yZP3Z9obNuby0urzsuGd32p//9Pzrx+vAxpOv3Fs/hAKvajUomUzUCSz2C/hk7eHTR0vDHiVJHZFpYlBs/XvHwpeLn9kW7tvv2x0Pv1hZsTmcAIohTbIxGl+p6pjnu2fVaiwW+va7tc9ti0glW8onumiFqaRO/CdrTsfdxTt37ffsj1YfOFbXn24A8sXganypm9psPh1eyN5DDwRl9na3X+ztEsgZCAY9ezv1MgT6g75dl+el++j4VSwe+TURxTAEMG8M41o3TO36xlQ0NRQJsQKLVitnmXiP5xmWT2dzf/35cTJ/J9AU12Us0qHck0S+3+cBzVAVbazr6h+/v72Z/Pbi5/2T194OjlAE1mFYaTAMh0PRKBiOxV2urQOf78jvb1PnsiTwAgOM1ZGiKeaNqWtXHRTKBbwdOMOSONEgDUM3DLNahaPh41QMPPR6fccHLvfm4aHrtc8Ti0cBc2IOZK5WiJf8B2g0wNZSaCVRgxEcPx+NRpeXI5JkoTOklEs24HypWEin4sGAd8e9+WzzG6AQOcp5XUXPFpYAuyTCUTBJtnu9vjWmaZjXpkVOEK0ajKK1As81S+VyLpctlzKhkA9IuX6s+F6eF5KSyHYYSlVHs/lkPp9++PD+06eP8/lM0bReX7T+n84ms5k5nRqtJpFMpVOpFJD1uIrRYJfr4ARqpS9KgigKmiVd1XWNIM7ZLmdtZahKUtTFhSwInDK+bDaQSDgIpBPBfDGTy2XqdZjjO/l8nqYtbFEUJbrdrr6BxYEkCH1JkvKFoj8QbLfpRDJdyicpLPd/wyCo+KZWbZFNjmfevX9r3YCROEXT//x722aY29u/caIJI5iijK0EdUOBEfjUH9rf3wcougnD1UYDg6Dy9rar0cCvRkNREi0fgtRPTgMohsuyzPOcrisk1XLv7pXKJRxHM9nMfyMmuCS0IHSgAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"일방통행\"\n        title=\"\"\n        src=\"/static/6337a2812f30b839cc498809f0d9e0a2/19e8f/image-13.png\"\n        srcset=\"/static/6337a2812f30b839cc498809f0d9e0a2/c26ae/image-13.png 158w,\n/static/6337a2812f30b839cc498809f0d9e0a2/19e8f/image-13.png 267w\"\n        sizes=\"(max-width: 267px) 100vw, 267px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이 메서드들은 페이지의 최상단에만 위치할 수 있었으며, 따라서 초기 데이터 로드는 <strong>페이지 단위</strong>로만 가능했습니다.<br>\n이것의 문제점은 위에서 살펴본 <em>React 18 이전 SSR의 한계</em> 에서 다룬대로입니다</p>\n<p>대신 Next.js 13에서 도입된 App Router는 :</p>\n<ul>\n<li>Server Components</li>\n<li>Streaming : UI를 조각별로 스트리밍하고 준비되는 대로 보여줌</li>\n<li>컴포넌트 수준의 data fetching : <code class=\"language-text\">async</code> 서버 컴포넌트 + 확장된 <code class=\"language-text\">fetch</code> api</li>\n</ul>\n<p>등 <strong>동시성</strong> 개념들을 지원합니다.<br>\n덕분에 이전 pages router와 같이 페이지 단위가 아닌, <strong>컴포넌트 단위</strong>로 서버를 활용하고 점진적 렌더링이 가능해졌네요</p>\n<hr>\n<p><br>\n원래 이번 글에서 RSC Payload나 Streaming이 어떻게 이루어지는지 예시까지 살펴보려고 했는데<br>\n점점 길어져서 다음 편을 써야곘어요<br>\n되게 대충대충 설명하고 넘어온 것 같은데 그래도 양이 많네요</p>\n<p>다음편에서는 실제로 SSR이 어떻게 Streaming되는지<br>\nSuspense 바운더리는 어떻게 교체되는지<br>\nRSC Payload가 어떻게 생겨먹었는지<br>\n등등을 실제로 간단한 코드와 함께 살펴보는 시간 갖도록 하겠습니다<br>\n그리고..</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c4c423b89bc7c309eb5b5af8adb274e3/1b747/image-14.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 91.13924050632912%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAADzklEQVR42n1TW28bVRDeFxrUtHZ8ib3xJbbX99hxnIsdxYntNJeW9gF4qgRCIOAFXqoKBLShaRGXFlRoy39B8FIlcZM0hEgIobSNvfbaXl8UIlHRhIQQJXzMOW6tgAorfZo5c2a+mTkzK8SGhzEwPIRoPIbkiUlEegeRSE1gaGQM7WInUmPPYTAxit6BBEZGTyJOuifQA7e/G95gD3RGK463maDRmTmE04lzmHrtG7x+5ia83SfgjyYQicbR1RNHlEhYULC7H4FwH3yku7wh2Jw+dEoBmC3OJlGT0O9MYzz2Fvr8L8IgetBu9cBotsMoOmCiAH27FQaTjUud0cJ1fk9gNkai1YtNCE63hMmJBDwhyuzwQOzohMUmUXbXP1p5Gg7faw0daCMIIgV2hXrhkIJUkQS9PQS9NQgNZTumbf9PtGqMT00osLL5m7j8hAA63WHYpS5YqVo72dkd020Ob+NM0ub0cv/DLTcJ2Vu4vGE43V18AB6anscfgUQ2X1e0YQswRPhkJV+YD0a0Np7k39UKDl8/Jt+4geTLVzH+6hdIk0y9dBWJs58g/co1DJ39FKfevIXkC2+jb2AIiSRbKdoGSvYEQdqADnp3RiqYKVMgMgi96ILR4oahQyK46SxBY7CjVUd7prehVSs2KqGKjreZ+QD4ZB8P45jWxMFb9oeiCEf6aanjCHX30R7GEKKzrVOCxe6ClUPiVYhWibcrWp1csl00WxzoIJ2tlBAbHMbM7BIyswuYn8tg5vY8bhNm5haxdHcJy8srWFhYQebOCr797gfMzZA9k8Hi7CIWZr/HfOYO7s4vQ86VcGFqGkJqdAKVchX5nIq8XEZBLqFWUlFWVJSUCsrFOuSsSgEqlLwKtVhDpVBH4acfsbY8g3y2iAr54C/gqxtfQxhJjaNGTrk1BaurWSJUUMjKdM5h7cEaIYd7q/c5ZFkm4nzDfu8BYRXFooKtzU2w7/qXNyEk0xOoVqsoFPLI5/NQCgpVUSbHIuS8DEVRONi9LOe4T6FQICioVKool5lvCXt7e0R4iypMj/PM2WwWOVYBkagqtVWpcVJVraBWq/GkpVIJ9Xqd25m+sbFBhCqPPzg4wLXPr0NIj53E1tYWHj36jePhrw/xy/rPWF/PYXPzd/y5+we2t7exs7PTlDskd3d2sb+/T0T7vDr28Tdkf8bFDy9j6tIVklfwwcVpvPveOZx/5zxN7TKf3PsXLpH9Mbg+ze+exDH9o48/w6nTz0NgS3rkqA4tRw0wGPTQaLUQTTpaYPqV2OYLLf+DI4fwDFqe1eBvsCz+MAlrTNwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"__next_f.push discussion\"\n        title=\"\"\n        src=\"/static/c4c423b89bc7c309eb5b5af8adb274e3/f058b/image-14.png\"\n        srcset=\"/static/c4c423b89bc7c309eb5b5af8adb274e3/c26ae/image-14.png 158w,\n/static/c4c423b89bc7c309eb5b5af8adb274e3/6bdcf/image-14.png 315w,\n/static/c4c423b89bc7c309eb5b5af8adb274e3/f058b/image-14.png 630w,\n/static/c4c423b89bc7c309eb5b5af8adb274e3/1b747/image-14.png 679w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>웹페이지를 두 배 무겁게 만드는 Next.js???<br>\n다음 글에 계속.</p>","frontmatter":{"title":"나는 Post-React18 시대에 산다","date":"March 01, 2025","description":"React 18 동시성 업데이트 - Streaming with Suspense, React Server Component 등","tag":["React","Next.js"]},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#react-18-%EC%9D%B4%EC%A0%84%EC%9D%98-%EC%8B%9C%EB%8C%80---csr-vs-ssr\">React 18 이전의 시대 - CSR vs SSR</a></p>\n<ul>\n<li><a href=\"#hydration%EC%9D%B4-%EA%B7%BC%EB%8D%B0-%EB%AD%94%EA%B0%80%EC%9A%94\">Hydration이 근데 뭔가요?</a></li>\n<li><a href=\"#react-18-%EC%9D%B4%EC%A0%84-ssr%EC%9D%98-%ED%95%9C%EA%B3%84\">React 18 이전 SSR의 한계?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#react-18---%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8\">React 18 - 동시성 업데이트</a></p>\n<ul>\n<li>\n<p><a href=\"#suspense\">Suspense</a></p>\n</li>\n<li>\n<p><a href=\"#streaming\">Streaming</a></p>\n<ul>\n<li>\n<p><a href=\"#streaming-html\">Streaming HTML</a></p>\n</li>\n<li>\n<p><a href=\"#streaming-ssr\">Streaming SSR</a></p>\n</li>\n<li>\n<p><a href=\"#react-server-component\">React Server Component</a></p>\n<ul>\n<li><a href=\"#rsc-payload\">RSC Payload?</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#selective-hydration\">Selective Hydration</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#post-react18%EC%9D%98-ssr%EC%9D%80-%EB%AD%94%EA%B0%80-%EB%8B%A4%EB%A6%84\">Post-React18의 SSR은 뭔가 다름</a></p>\n</li>\n<li>\n<p><a href=\"#react-18%EC%9D%B4-%EA%B0%80%EC%A0%B8%EC%98%A8-%EB%B3%80%ED%99%94--nextjs-13-app-router\">React 18이 가져온 변화 : Next.js 13 App Router</a></p>\n</li>\n</ul>"},"previous":{"fields":{"slug":"/til/some-tips-using-mantine/"},"frontmatter":{"title":"Mantine polymorphic으로 두 Mantine 컴포넌트 합치기 "}},"next":null},"pageContext":{"id":"0106321e-2cce-52cd-aab4-f3ec91c286f0","previousPostId":"92369ac2-cacc-5929-be72-ae891833c1f6","nextPostId":null}},"staticQueryHashes":["2841359383"],"slicesMap":{}}