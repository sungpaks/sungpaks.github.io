{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/studying-typescript-day1/","result":{"data":{"site":{"siteMetadata":{"title":"조성개발실록"}},"markdownRemark":{"id":"692e663e-b25f-5719-9c79-9761cc75ed2d","excerpt":"안녕하세요. 오늘은 TypeScript 가져왔습니다. 저도 TypeScript는 처음 써보는데요.. 이게 저는 C나 C++, Java…","html":"<p>안녕하세요.<br>\n오늘은 TypeScript 가져왔습니다.<br>\n저도 TypeScript는 처음 써보는데요..<br>\n이게 저는 C나 C++, Java..같은<br>\n<code class=\"language-text\">int a = 10;</code> 이런 것만 해봤고<br>\n이거에 익숙해서 그런지<br>\n그냥 냅다 <code class=\"language-text\">const a = 10;</code> 이런 식으로 쓰는거 정말 적응 안됩니다.<br>\n그리고 요새는 파이썬을 또한 다시 만져보고 있는데<br>\n<code class=\"language-text\">a = 10</code> 이건 정말.. 더 그러네요</p>\n<p>아무튼 이렇게 Javscript는 타입이 불분명하다는 점 때문에 다른 사람들도 어지간히 불편했나 봅니다.<br>\n이런 니즈가 있었기에 마이크로소프트에서 <strong>TypeScript</strong>라는 것을 내놓았는데요<br>\n꽤나 널리 쓰이게 된지 좀 된 것 같습니다</p>\n<p>그래서 남들 하는건 저도 해야겠으니<br>\n어떻게 공부를 시작해볼까? 생각하다가 그냥<br>\n쩝.. Document나 열어봐야지.. 하여 좀 살펴봤습니다<br>\nTypeScript는 친절하게도 여러 수준의 맞춤형 핸드북을 제공합니다<br>\n저는 JavaScript Programmer를 위한.. <a href=\"https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html\">이거</a>를 골라봤습니다.<br>\n저랑 같이 공부 허쉴?</p>\n<h2>TypeScript는요..</h2>\n<p><a href=\"https://www.typescriptlang.org/\">여기</a>에서 소개하는 TypeScript의 특징? 편의성? 머 아무튼 그런거는</p>\n<ul>\n<li>에디터에서 타입을 체크해줍니다</li>\n<li>자동완성도 해줍니다</li>\n<li><code class=\"language-text\">interface</code>를 제공합니다. (구조체와 유사)</li>\n<li>JSX에서도, props같은거 타입을 지정할 수 있게 해줍니다.</li>\n</ul>\n<p>음.. 좋네요<br>\n이제 본격적으로 뜯어봅니다<br>\n아 그리고 이제 귀찮으니까 TypeScript는 TS로 줄여서 쓰겠습니다. JavaScript도 JS로 줄여쓰고싶어지면 그렇게 하겠습니다.</p>\n<h2>Types By Inference</h2>\n<p>타입을 추론하여 정한다는 내용인데요<br>\n예를 들어, 이전에 보통 Javascript에서 으레 하듯이<br>\n<code class=\"language-text\">let helloWorld = \"Hello World\";</code>라고 쓴다면<br>\nTS는 아! <code class=\"language-text\">helloWorld</code>는 <code class=\"language-text\">string</code> 타입이다! 를 기억합니다<br>\n그럼 이제 나중에 10같은 <code class=\"language-text\">number</code>값을 실수로 넣는 상황이 되어도 빨간줄을 좍좍 그어줍니다. 이렇게\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 331px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/e994a8e01f3d3e504a0217eb8466d505/62452/image.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 24.68354430379747%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABDklEQVR42lWQ6Y6CMBSFff9XM7NEx52JAgq1FLqwFCHyTQd/eZPm3pM23+k9C+8nlJ5w9UBRSLLshjGaJIm5C4m8S6wx9L7HdobM5AibU3sXtCXTGdIV4QhM61jUzUgsRozrieOYcwClAbpar7hcLiRpgpQCay1N5ziJI2mZzABp7kGfuFZX8gB2TQDmccLma8nv7ofd5wer5ZI0ijjvNnj/oHSKg9izPx4YhoH3mt7V9GTRFTlyu2IUN8T2G7lfI8Lv9DkKERSUZVhHSaJgIqVEqQJjDW1bhztFoV5vmrZ5AR9Dhx/87DA+R/qhp9Q69IGqKsOqJmRqZlhVVWhdUTc1vmvn+T9vFbJ3zs2MP9c0eOAgOueFAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"image\" title=\"\" src=\"/static/e994a8e01f3d3e504a0217eb8466d505/62452/image.png\" srcset=\"/static/e994a8e01f3d3e504a0217eb8466d505/c26ae/image.png 158w,\n/static/e994a8e01f3d3e504a0217eb8466d505/6bdcf/image.png 315w,\n/static/e994a8e01f3d3e504a0217eb8466d505/62452/image.png 331w\" sizes=\"(max-width: 331px) 100vw, 331px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span></p>\n<h2>Defining Types</h2>\n<p>타입을 정의한다는 내용인데요<br>\n항상 위에서처럼 타입 추론에 의지할 수는 없습니다<br>\n디자인 패턴에 따라서는 명시를 해야할 수도 있고,<br>\n그게 아니더라도 선언과 동시에 값을 초기화하지 않을 수도 있죠?</p>\n<p>따라서 TS는 사용자에게 타입을 명시할 수 있도록 extension을 제공합니다.<br>\n이름이라면 응당 문자열이게끔 <code class=\"language-text\">name: string</code>과 같이 쓴다던가,<br>\n학번이라면 당연히 숫자이게끔 <code class=\"language-text\">id: number</code>라고 쓴다던가.. 말입니다</p>\n<p>만약 Sungho라는 이름의, 학번이 190001인 학생이 있다면<br>\n<code class=\"language-text\">const student = {name: \"Sungho\", id: 190001};</code>\n이렇게 작성할 수 있을텐데요\n대신 좀 더 엄격하게, TS를 이용하여 <code class=\"language-text\">interface</code>를 선언하고 사용해볼 수 있습니다 :</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  id<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> student<span class=\"token operator\">:</span> Student <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">\"Sungho\"</span><span class=\"token punctuation\">,</span> id<span class=\"token operator\">:</span> <span class=\"token number\">190001</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게, <code class=\"language-text\">interface</code>를 선언하고 사용하여 객체의 각 property의 타입을 강제할 수 있습니다.<br>\n이렇게 쓰면 좋은 점은, 타입을 잘못 쓴 경우 (<code class=\"language-text\">name: 190001</code>처럼..)말고도 하나 더있는데요,<br>\n예를 들어 property 이름이 헷갈려서 이름을 <code class=\"language-text\">username: \"Sungho\"</code>라고 써버리는 상황을 또한 방지할 수 있습니다.</p>\n<p>아 그리고 객체지향언어인 JS는 클래스가 있으니까 TS에서도</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">StudentAccount</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  id<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> id<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> id\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 타입을 정의할 수 있습니다.<br>\nTS의 신기한 특징은, 위에서 살펴본 <code class=\"language-text\">interface Student</code>에 대해<br>\n<code class=\"language-text\">const student: Student = new StudentAccount(\"Sungho\", 190001);</code><br>\n과 같이 써버릴 수 있습니다.<br>\nTS가 <em>Structural Type System</em>이라서 가능한데, 이거에 관해서는 밑에서 다룹니다</p>\n<p>그리고 함수에서도,<br>\n<code class=\"language-text\">function setStudent(student: Student) {}</code>와 같이 인자 타입을 정의할 수도 있고<br>\n<code class=\"language-text\">function getStudent(): Student {}</code>와 같이 리턴값의 타입을 정의할 수도 있습니다.</p>\n<p>이 정의할 수 있는 타입은<br>\nJS에서 기본적으로 존재하는 primitive type인</p>\n<ul>\n<li><code class=\"language-text\">boolean</code>, <code class=\"language-text\">bigint</code>, <code class=\"language-text\">null</code>, <code class=\"language-text\">number</code>, <code class=\"language-text\">string</code>, <code class=\"language-text\">symbol</code>, <code class=\"language-text\">undefined</code></li>\n</ul>\n<p>이런 거에 추가로 TS에서 지원하는 타입으로</p>\n<ul>\n<li><code class=\"language-text\">any</code> : 뭐든 허용</li>\n<li><code class=\"language-text\">unknown</code> : <code class=\"language-text\">any</code>와 비슷하지만, 실제로 사용 시 타입을 써야 함</li>\n<li><code class=\"language-text\">never</code> : 값이 항상 없음..을 의미하는데, 어떤 함수가 무한루프를 돌거나 항상 오류를 발생시키는 등 \"리턴 값이 절대 없음\" 을 나타내는 상황 등에서 이용하나봅니다</li>\n<li><code class=\"language-text\">void</code> : 함수가 <code class=\"language-text\">undefined</code>를 반환하거나 반환값이 없을 때</li>\n</ul>\n<h3><code class=\"language-text\">type alias</code> vs <code class=\"language-text\">interface</code> ?</h3>\n<p>새에 관한 타입을 만들고자 할 때, 두 가지 방법이 있습니다</p>\n<ul>\n<li><code class=\"language-text\">type BirdType = {wings: 2;};</code> : <em>type alias</em></li>\n<li><code class=\"language-text\">interface BirdInterface {wings: 2;}</code> : <em>interface</em></li>\n</ul>\n<p>대부분의 경우 이 두 방법은 거의 유사하지만, 조금의 차이점이 있고, 공식문서에서는 웬만하면 <code class=\"language-text\">interface</code>를 사용하는게 좋겠다고 말하네요</p>\n<p>유사한 점은</p>\n<ul>\n<li>둘 다 property만 공통적이면 섞어쓸 수 있습니다.(intermix.) 이건 위에서 언급한 <em>Structural Type System</em>에 의한 특징</li>\n<li>확장 가능 : 방식은 다릅니다.. 이런 식으로\n<ul>\n<li><code class=\"language-text\">type Owl = {nocturnal: true} &amp; BirdType</code></li>\n<li><code class=\"language-text\">interface Chicken extends BirdInterface{colorful : false}</code></li>\n</ul>\n</li>\n</ul>\n<p>근데 이제 다른 점이 무엇이냐</p>\n<ul>\n<li>property가 공통적이지 않은데 intermix를 시도하는 경우 에러메시지가 다릅니다. 대충 <code class=\"language-text\">interface</code>를 쓰는 편이 더 직관적이고 간결하다고 설명하네요</li>\n<li>또 중요한 차이점은, \"<code class=\"language-text\">interface</code>는 <code class=\"language-text\">open</code>이고, <code class=\"language-text\">type alias</code>는 <code class=\"language-text\">close</code>\"라는 것인데 : - <code class=\"language-text\">interface</code>는 두 번 선언하면 확장됩니다. 예를 들어\n<code class=\"language-text\">interface Kitten {purrs : boolean;}</code> 그 다음에\n<code class=\"language-text\">interface Kitten {color: string;}</code> 이렇게 쓰면 <code class=\"language-text\">Kitten</code> 인터페이스는 확장됩니다. (property 둘 다 가짐)</li>\n<li>근데 <code class=\"language-text\">type</code>은 두 번 써버리면 그 자체로 성립이 불가\n<img src=\"https://i.imgur.com/GROaGdy.png\" width=\"100%\"></li>\n</ul>\n<p>뭐 그렇다네요. 적당히 주의하도록 합시다</p>\n<h2>Composing Types</h2>\n<p>이제 타입을 구성해봅시다<br>\nTS와 함께라면 복잡한 타입도 구성해볼 수 있습니다</p>\n<ul>\n<li>Unions : 여러 타입을 결합합니다. 예컨대 <code class=\"language-text\">type MyBool = true | false;</code> 등..\n<ul>\n<li>어떤 변수에 들어갈 값을 특정 리터럴로 제한할 때 강력합니다. 예를 들면\n<ul>\n<li><code class=\"language-text\">type siblings = \"brother\" | \"sister\";</code></li>\n<li><code class=\"language-text\">type PrimeNumberUnderTen = 2 | 3 | 5 | 7;</code></li>\n</ul>\n</li>\n<li>또는 타입을 둘 이상 허용할 때 쓸 수 있습니다. (<code class=\"language-text\">string</code> 또는 <code class=\"language-text\">string</code>의 배열)\n<ul>\n<li><em>참고 : <code class=\"language-text\">typeof</code>연산자로 타입을 확인할 수 있습니다.</em> <code class=\"language-text\">if (typeof obj === \"string\")</code> 이런 식</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Generics : Array가 담을 수 있는 <code class=\"language-text\">type</code>을 제한할 수 있습니다.\n<ul>\n<li><code class=\"language-text\">type StringArray = Array&lt;string>;</code> 이런 식</li>\n<li>또는, <code class=\"language-text\">type ObjectWithNameArray = Array&lt;{ name: string} >;</code> 이렇게 쓰면 property로 <code class=\"language-text\">name</code>을 가지는 애들만 넣도록 할 수 있습니다.</li>\n<li><code class=\"language-text\">&lt;T></code> 와 같이 써서, 타입을 변수처럼 취급할 수 있습니다. (ex : <code class=\"language-text\">interface Backpack&lt;T>{}</code>)<br>\n이런 인터페이스에 대해, <code class=\"language-text\">declare const backpack: Backpack&lt;string>;</code>과 같이 작성하여 원하는 타입에 대한 <code class=\"language-text\">Backpack&lt;T></code> 객체를 생성할 수 있습니다</li>\n</ul>\n</li>\n</ul>\n<h2>Structural Type System</h2>\n<p>위에서 계속 언급한 <strong>Structural Type System</strong>인데요<br>\nC++같은 다른 언어에서는 <strong>nominal typing</strong>이라고 해서, 클래스의 이름으로 타입을 결정하고 구분짓습니다.<br>\n이와 달리, TS는 내부 <em>모양</em>을 보고 타입을 처리합니다.<br>\n그말인 즉, 내부가 똑같이 생겼다면 동일한 타입으로 간주할 수 있습니다.<br>\n예를 들어, <code class=\"language-text\">type MyBoolean = true | false</code> 이렇게 쓰면 그냥 <code class=\"language-text\">boolean</code>으로 받아들입니다.</p>\n<p>예를 들어</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Point</span> <span class=\"token punctuation\">{</span>\n  x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>\n  y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">//이런 인터페이스가 있고</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">logPoint</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> Point<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">//이런 함수가 있을 때</span>\n\n<span class=\"token keyword\">const</span> point1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token number\">26</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> point2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token number\">26</span><span class=\"token punctuation\">,</span> z<span class=\"token operator\">:</span> <span class=\"token number\">89</span> <span class=\"token punctuation\">}</span>\n<span class=\"token function\">logPoint</span><span class=\"token punctuation\">(</span>point1<span class=\"token punctuation\">)</span>\n<span class=\"token function\">logPoint</span><span class=\"token punctuation\">(</span>point2<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//둘 다 가능</span></code></pre></div>\n<p><code class=\"language-text\">point1</code>은 당연히 가능하고, <code class=\"language-text\">point2</code>또한 property의 subset이 조건을 만족하므로 가능합니다.<br>\n예시에서는 살펴보지 않았지만, 클래스에 대해서도 다를 것 없이<br>\n<code class=\"language-text\">x: number</code>, <code class=\"language-text\">y: number</code> 필드만 가지고 있다면 동일한 타입으로 취급받을 수 있습니다.</p>\n<br/>\n<br/>\n<br/>\n<p>여기까지가 TypeScript 문법에 관한 간단한 오버뷰라고 하네요<br>\n이 다음은</p>\n<ul>\n<li>핸드북 다 읽어보기 : <a href=\"https://www.typescriptlang.org/docs/handbook/intro.html\">from start to finish</a></li>\n<li>예제 풀어보기 : <a href=\"https://www.typescriptlang.org/play#show-examples\">Playground examples</a></li>\n</ul>\n<p>이런게 준비되어있다고 합니다<br>\nDay 2를 쓸지는 모르겠지만..<br>\n이만 마칩니다</p>","frontmatter":{"title":"😏 저랑.. 타입스크립트 공부 하실래요? (TypeScript)","date":"January 04, 2024","description":"TypeScript Document 스터디 윗 미.","tag":["TypeScript","JavaScript"]},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#typescript%EB%8A%94%EC%9A%94\">TypeScript는요..</a></p>\n</li>\n<li>\n<p><a href=\"#types-by-inference\">Types By Inference</a></p>\n</li>\n<li>\n<p><a href=\"#defining-types\">Defining Types</a></p>\n<ul>\n<li><a href=\"#code-classlanguage-texttype-aliascode-vs-code-classlanguage-textinterfacecode-\"><code class=\"language-text\">type alias</code> vs <code class=\"language-text\">interface</code> ?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#composing-types\">Composing Types</a></p>\n</li>\n<li>\n<p><a href=\"#structural-type-system\">Structural Type System</a></p>\n</li>\n</ul>"},"previous":{"fields":{"slug":"/multi-threading-in-cpp/"},"frontmatter":{"title":"👥 C++ 멀티스레딩 맛 한번 보세요"}},"next":{"fields":{"slug":"/how-to-make-obsidian-plugin/"},"frontmatter":{"title":"🔌 옵시디언 플러그인 개발 이렇게 시작해보세요"}}},"pageContext":{"id":"692e663e-b25f-5719-9c79-9761cc75ed2d","previousPostId":"db93ec6a-4556-5de7-87a4-797032932351","nextPostId":"5a653c52-2ca1-597a-adfc-d04e90e7119f"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}