{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/til/geolocation-based-running-tracker-improvement/","result":{"data":{"site":{"siteMetadata":{"title":"조성개발실록"}},"markdownRemark":{"id":"49400dce-d52b-50fc-8853-f00c147b5581","excerpt":"! 주의 : TIL 게시글입니다. 다듬지 않고 올리거나 기록을 통째로 복붙했을 수 있는 뒷고기 포스팅입니다. 이전 포스팅에서는 프로토타입을 개발해봤었습니다 이제 진짜 서비스를 만들어야 하니, 신경쓸게 산더미입니다 정확도 향상 https://developer.mozilla.org/ko…","html":"<p>! 주의 : TIL 게시글입니다. 다듬지 않고 올리거나 기록을 통째로 복붙했을 수 있는 뒷고기 포스팅입니다.</p>\n<p><a href=\"https://sungpaks.github.io/til/geolocation-based-running-tracker-prototype/\">이전 포스팅에서는 프로토타입을 개발해봤었습니다</a></p>\n<p>이제 진짜 서비스를 만들어야 하니, 신경쓸게 산더미입니다</p>\n<h1 id=\"정확도-향상\" style=\"position:relative;\"><a href=\"#%EC%A0%95%ED%99%95%EB%8F%84-%ED%96%A5%EC%83%81\" aria-label=\"정확도 향상 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정확도 향상</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/Geolocation/getCurrentPosition\">https://developer.mozilla.org/ko/docs/Web/API/Geolocation/getCurrentPosition</a>\n<a href=\"https://developer.mozilla.org/ko/docs/Web/API/Geolocation/getCurrentPosition\">https://developer.mozilla.org/ko/docs/Web/API/Geolocation/getCurrentPosition</a>\n옵션에 highAccuracy를 강제하게 하거나, timeout을 정하거나 해서 정확도를 올릴 수 있다<br>\n그리고 latitude, longitude 외에 accuracy도 있어서, 이게 일정 값을 벗어나면 계산에 포함하지 않게 하는 것도 방법인 듯.</p>\n<p>그리고 현재 위치가 별로 정확하지 않다고 판단되면<br>\n<code class=\"language-text\">getCurrentPosition</code>으로 위치를 갱신하게 할 수 있게 할까? 해서 넣어봤는데<br>\n어차피 별 효과가 없다. 새로고침해도 그대로였음</p>\n<p>근데 어차피 PC웹에서는 IP주소 기반 위치 인식이라.. 정확도가 떨어지는게 어쩔 수 없고<br>\n모바일웹에서는 기기 특성 상 정확도가 좋고,<br>\n테스트 결과 걱정하지 않아도 될 정도의 정확도가 나와서<br>\n위에서 <code class=\"language-text\">accuracy</code> 관련 로직만 살짝 추가해주는 정도로 괜찮은 듯</p>\n<p>어차피 PC를 들고 돌아다녀 볼 수도 없는 노릇이니<br>\n개발환경 전용 테스트를 좀 만들었다<br>\n테스트모드에서는 지도를 드래그해서 그 지도 중앙이 현재 위치가 되도록 하게끔.</p>\n<p>그리고 이 과정에서.. 이제서야 정확히 알게 된 사실<br>\n<a href=\"https://www.dhiwise.com/post/guide-to-state-management-with-react-setstate-callback\"><strong><em>setState는 비동기적이다</em></strong></a><br>\n<code class=\"language-text\">setState</code>에 콜백함수를 넘기는 까닭이 바로.</p>\n<h1 id=\"이전-러닝-상태-복구\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A0%84-%EB%9F%AC%EB%8B%9D-%EC%83%81%ED%83%9C-%EB%B3%B5%EA%B5%AC\" aria-label=\"이전 러닝 상태 복구 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이전 러닝 상태 복구</h1>\n<p>러닝 시, 불의의 사태로 서비스를 껐다가 켜게 될 수도 있고,<br>\n사용자가 갑자기 다른 화면으로 넘어갈 수도 있고,<br>\n또는 사용자가 갑자기 새로고침을 해버릴 수도 있고, ..</p>\n<p>따라서 새로운 마운트 시 러닝 상태를 복구해야만 했다!<br>\n이를 위해 백엔드에서는</p>\n<ul>\n<li>러닝 상태를 업데이트하는 <code class=\"language-text\">post</code></li>\n<li>특정 러닝 상태 정보를 가져오는 <code class=\"language-text\">get</code></li>\n</ul>\n<p>이런 api를 만들어줬다</p>\n<p>이제 러닝을 시작하면,</p>\n<ol>\n<li>시작할 때 러닝 정보 생성 요청(백엔드에 <code class=\"language-text\">post</code>)</li>\n<li><code class=\"language-text\">post</code> 결과로 백엔드에 러닝 정보가 생성되고, 응답으로 생성된 러닝 상태 id를 받는다.</li>\n<li>이 <code class=\"language-text\">runningId</code>는 로컬스토리지에 갖고있자.\n<ul>\n<li>처음부터 여기서 Recoil같은 전역상태 라이브러리 써도 괜찮았을 것 같다.</li>\n<li>근데 <code class=\"language-text\">useContext</code>만으로 좀 해보고싶어서 욕심을 부렸다</li>\n<li>그냥 상태만으로는 마운트 시 값이 초기화되므로, 로컬스토리지에 저장해야만 했음</li>\n<li>로컬스토리지에 저장한다는 사실이 좀 찜찜했는데.. 쓰라고 만든건데 안 쓸 이유가?</li>\n</ul>\n</li>\n</ol>\n<p>이제 러닝 진행 시에는</p>\n<ol>\n<li>매 위치 변동마다 <code class=\"language-text\">post</code>요청의 requestBody로 이동한 거리, 페이스, 경도와 위도, ... 이런거를 보낸다</li>\n<li>새로고침같이 새로운 마운트가 발생하면?</li>\n<li>로컬스토리지에서 <code class=\"language-text\">runningId</code>를 가져오고</li>\n<li>해당 <code class=\"language-text\">runningId</code>로 서버에 <code class=\"language-text\">get</code>요청을 하여 이전 정보를 받아온다</li>\n<li>이를 바탕으로 이전 state들 복구</li>\n<li>타이머도 이어서 시작하게 해야 하는데, 이거는 서버 정보로부터 복원하기보다는 <code class=\"language-text\">setInterval</code> 시간을 계속 localStorage에 저장하고 이걸 다시 가져오는게 여러모로 용이했음</li>\n</ol>\n<p>이제 러닝 종료 시에 이 localStorage 정보들을 삭제해주기만 하면 됨.</p>\n<p>아예 화면을 나갔다가 다시 오면?</p>\n<ol>\n<li>localStorage에 <code class=\"language-text\">runningId</code> 있는지, 있으면 유효하고 진행중이었는지 확인.</li>\n<li>진행중이었으면, 목표 페이스 설정 등을 건너뛰고 러닝을 바로 재개, 그렇지 않으면 localStorage에서 삭제</li>\n<li>이렇게 하면, 사용자가 임의로 (뒤로가기, 경로 직접 입력 등) 러닝 진행 페이지로 진입하려는 경우, 진행중인 러닝이 없으면 리다이렉션시킬 수 있음</li>\n</ol>","frontmatter":{"title":"위치 기반 러닝 트래커 고도화를 위한 고민들","date":"August 06, 2024","description":"아오.. 신경쓸게 많네요?","tag":["TIL","React"]},"tableOfContents":"<ul>\n<li><a href=\"#%EC%A0%95%ED%99%95%EB%8F%84-%ED%96%A5%EC%83%81\">정확도 향상</a></li>\n<li><a href=\"#%EC%9D%B4%EC%A0%84-%EB%9F%AC%EB%8B%9D-%EC%83%81%ED%83%9C-%EB%B3%B5%EA%B5%AC\">이전 러닝 상태 복구</a></li>\n</ul>"},"previous":{"fields":{"slug":"/deploy-your-project-with-vercel/"},"frontmatter":{"title":"📡 Vercel과 함께라면 배포도 두렵지 않아"}},"next":{"fields":{"slug":"/til/html-audio-volume-control-with-recoil/"},"frontmatter":{"title":"HTML <audio> 태그로 음향 넣기 & Recoil로 전역 음량관리"}}},"pageContext":{"id":"49400dce-d52b-50fc-8853-f00c147b5581","previousPostId":"cd977888-0e73-567b-aabf-937a5c08a5b5","nextPostId":"92781404-cf6d-574c-888a-b7c3fa93ed08"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}