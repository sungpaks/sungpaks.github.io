{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/til/react-life-hacks-2/","result":{"data":{"site":{"siteMetadata":{"title":"조성개발실록"}},"markdownRemark":{"id":"f39c37a6-8402-594f-ba50-594edd716f6c","excerpt":"! 주의 : TIL 게시글입니다. 다듬지 않고 올리거나 기록을 통째로 복붙했을 수 있는 뒷고기 포스팅입니다. 거두절미 useEffect에 대해 useEffect…","html":"<blockquote>\n<p>! 주의 : TIL 게시글입니다. 다듬지 않고 올리거나 기록을 통째로 복붙했을 수 있는 뒷고기 포스팅입니다.</p>\n</blockquote>\n<p>거두절미</p>\n<h1 id=\"useeffect에-대해\" style=\"position:relative;\"><a href=\"#useeffect%EC%97%90-%EB%8C%80%ED%95%B4\" aria-label=\"useeffect에 대해 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useEffect에 대해</h1>\n<h2 id=\"useeffect-필요한-경우\" style=\"position:relative;\"><a href=\"#useeffect-%ED%95%84%EC%9A%94%ED%95%9C-%EA%B2%BD%EC%9A%B0\" aria-label=\"useeffect 필요한 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useEffect 필요한 경우?</h2>\n<p>알고들 계시리라 봅니다만,<br>\n함수형 컴포넌트가 렌더링될 때<br>\n이 컴포넌트 함수가 실행되는 양상을 살펴봅시다</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">,</span> setValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prev</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> prev <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>대충 이런 <code class=\"language-text\">Foo.jsx</code>가 있다고 생각해봅시다<br>\n1초마다 1씩 값이 늘어나는 것을 상상하고 이런 코드를 작성했을 수 있지만<br>\n매우 끔찍한 일이 일어납니다.. 궁금하면 직접 해보세요.</p>\n<iframe src=\"https://codesandbox.io/embed/z6sthx?view=preview&module=%2Fsrc%2FApp.js&hidenavigation=1\"\n     style=\"width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"fast-snow\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>\n<p>아유.. 귀찮은데 샌드박스 만들어왔습니다</p>\n<p>이유는 아시다시피<br>\n<code class=\"language-text\">setState()</code>는 컴포넌트 함수의 재실행을 촉발합니다<br>\n그럼 <code class=\"language-text\">setInterval</code>에 의해 1초 뒤 <code class=\"language-text\">setValue()</code>가 호출되고,<br>\n그럼 이제 다시 Foo 컴포넌트 함수가 재실행됩니다<br>\n그럼 다시 <code class=\"language-text\">setInterval</code>이 추가되고, 1초 뒤 <code class=\"language-text\">setValue()</code>가 호출되고, 또 Foo 컴포넌트 함수가 실행되고, ..<br>\n근데 <code class=\"language-text\">setInterval</code>은 계속 남습니다. 이건 함수 컴포넌트가 재실행된다고 없어지지 않아요<br>\n사실상 미아가 되는건데..<br>\n그러면 미아 interval이 배로배로 늘어나버립니다</p>\n<p><code class=\"language-text\">setInterval</code> 없이 그냥 냅다 <code class=\"language-text\">setValue()</code>를 바로 부르면 더 직관적일까요?</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">,</span> setValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//여기서 사실상 Foo()를 다시 호출하는 셈임</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이러면 <code class=\"language-text\">Too many re-renders.</code> 에러가 나버립니다<br>\n<code class=\"language-text\">setValue()</code>를 만나면 <code class=\"language-text\">Foo()</code> 컴포넌트 함수는 다시 실행되므로 답없는 재귀함수가 되는 셈입니다</p>\n<h2 id=\"useeffect로-해결\" style=\"position:relative;\"><a href=\"#useeffect%EB%A1%9C-%ED%95%B4%EA%B2%B0\" aria-label=\"useeffect로 해결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useEffect로 해결</h2>\n<p>그럼 이런거 한 번만 실행하게 하려고 <code class=\"language-text\">useEffect</code>를 쓴다는 사실 알고계시죠??<br>\nhttp api를 호출할 때나 저런거 할 때나, <code class=\"language-text\">useEffect()</code>를 의존성배열을 비운 채 사용하여<br>\n<strong>최초 마운트 시 1회만 실행</strong>하게 합니다<br>\n아래처럼요</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useEffect<span class=\"token punctuation\">,</span> useRef<span class=\"token punctuation\">,</span> useState <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> isInitial <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">,</span> setValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">//이 useEffect로 감싼 코드는 통째로 가져다가..</span>\n    <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prev</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> prev <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">//여기까지 다 실행한 타이밍에 useEffect에 담긴 코드를 실행함</span>\n</code></pre></div>\n<p>React는 컴포넌트 함수를 실행중에 <code class=\"language-text\">useEffect</code>훅을 만나면 해당 부분을 건너뜁니다.<br>\n그 <code class=\"language-text\">useEffect</code>내에 있던 코드는 가지고 있다가, 컴포넌트 함수 실행이 끝나면 실행합니다.</p>\n<p>그럼 먼저, <code class=\"language-text\">setInterval</code>은 건너뛴 채 렌더링이 완료되고,<br>\n이제 <code class=\"language-text\">useEffect</code>가 실행되므로 타이머가 세팅됩니다<br>\n이후 1초가 지나서 <code class=\"language-text\">setValue()</code>가 실행되었지만..<br>\n<strong>의존성 배열이 비어있기 때문에 <code class=\"language-text\">useEffect</code>내부는 다음 렌더링 때 재실행되지 않습니다</strong>.</p>\n<h2 id=\"거기선-useeffect-쓰지-마세요\" style=\"position:relative;\"><a href=\"#%EA%B1%B0%EA%B8%B0%EC%84%A0-useeffect-%EC%93%B0%EC%A7%80-%EB%A7%88%EC%84%B8%EC%9A%94\" aria-label=\"거기선 useeffect 쓰지 마세요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>거기선 useEffect 쓰지 마세요</h2>\n<p><a href=\"https://ko.react.dev/learn/you-might-not-need-an-effect#\">useEffect가 필요하지 않을 수도 있습니다.</a></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> storedIds <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>localStorage<span class=\"token punctuation\">.</span><span class=\"token function\">getItem</span><span class=\"token punctuation\">(</span><span class=\"token string\">'selectedPlaces'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>storedIds<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tlocalStorage<span class=\"token punctuation\">.</span><span class=\"token function\">setItem</span><span class=\"token punctuation\">(</span><span class=\"token string\">'selectedPlaces'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>storedIds<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이런게 있다고 칩시다<br>\n이런거 useEffect로 빼야 할까요?<br>\n굳이.. 인데요, <em>state 변화</em>도 없고, 더군다나 localStorage에 갔다오는 것은 <em>동기적</em>인 동작이기 떄문입니다</p>\n<p><em>이벤트핸들러</em>도 마찬가지입니다. 특정 조건에서만 호출되므로 위에서 살펴본 끔찍한 일이 벌어지지 않습니다..</p>\n<p>이외에도, <code class=\"language-text\">useEffect</code>를 굳이 사용하지 않을 상황이 많으니 링크를 살펴보세요</p>\n<h2 id=\"clean-up-함수\" style=\"position:relative;\"><a href=\"#clean-up-%ED%95%A8%EC%88%98\" aria-label=\"clean up 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>clean up 함수</h2>\n<p><code class=\"language-text\">useEffect</code>는 컴포넌트 함수의 실행이 끝난 뒤 호출된다고 말씀드렸습니다<br>\n그런데 또한, <code class=\"language-text\">useEffect</code> 내부에 전달하는 콜백함수 내에서 함수를 return하면<br>\n해당 함수는 <code class=\"language-text\">useEffect</code> 내부가 재실행되기 직전, 또는 컴포넌트가 사라지기 바로 직전에 실행됩니다<br>\n아래처럼요</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">let</span> timer <span class=\"token operator\">=</span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">// ...</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token comment\">//Clean Up 함수</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">clearTimeout</span><span class=\"token punctuation\">(</span>timer<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>이러면 이 <code class=\"language-text\">useEffect</code>가 속한 컴포넌트가 DOM에서 제거되기 직전에 <code class=\"language-text\">()=>{clearTImeout(timer)}</code>가 실행됩니다.<br>\n또한 의존성 배열에 값이 뭔가 있었다면, 그 값이 변화되어 리렌더링이 진행될 때도 실행되겠네요<br>\n아, 그리고 useEffect 내부의 최초 실행 시에는 당연히 Clean Up함수가 실행되지 않습니다</p>\n<p>의존성 배열에 값이 있는 경우에 대해서까지는 다루지 않아도 될거라고 생각합니다<br>\n<code class=\"language-text\">useEffect</code>에 대해 밑바닥부터 알고 싶으시면 <a href=\"https://ko.react.dev/reference/react/useEffect\">공식문서</a> 또는 <a href=\"https://sungpaks.github.io/react-hooks-guide-with-examples/#effect-hooks\">이상한 사람이 쓴 글</a>을 참고하세요</p>\n<h1 id=\"react가-화면을-그리는-비밀\" style=\"position:relative;\"><a href=\"#react%EA%B0%80-%ED%99%94%EB%A9%B4%EC%9D%84-%EA%B7%B8%EB%A6%AC%EB%8A%94-%EB%B9%84%EB%B0%80\" aria-label=\"react가 화면을 그리는 비밀 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React가 화면을 그리는 비밀</h1>\n<h2 id=\"virtual-dom\" style=\"position:relative;\"><a href=\"#virtual-dom\" aria-label=\"virtual dom permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Virtual DOM</h2>\n<figure>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1a3f8bfe49b335ad2c92cec36d198010/00d43/image.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABjklEQVR42n1R207CQBDtR/kHRBIf9MkP0FeJxkSUkOCLPvpJPhkVlXiFlnJvKd1Lpd2FbQuUQusASjAYT7KbnTMzO3NmpHgO3/cJpYSQKIrAjH4Q/wYw0+kUHgZHMqlKS0ehVKzqrUXEes4fZBxJC46JXpuSNsHewIe/GWOUUoyx53nL74C3bZtaFsJYCAHMdzIXwun3P7nTd0UwGgXj8c1LwbQo5IEihBDnHN6jILh9e9FQZ1FcWu1z2R51bA0jDZtBEEARhzFXiC5zsN3VCabMAddkMpHWlMzQg1jf6zI2XZHq+j4wlm07nFuODS4JSrUIUvSmorcqhlYzjYqhw93AnTrqqIZeNw21rbkDfzYaxt7LSr3VHA4Gs7a94XD/6nIre7ydO0lmjnbO08nM4cbBXuI0tZ1Lb54d7l5kE+nU9XMBoofj4LWqGhaN5holmOFrvfKoyoVKOa8U7+ViXindyh938seTKj+UwSzeld65K7joN0wDNtKxqNyoheua/wFMaByGsIgwDOFEcfwF7ZkjGbnRAqAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Rect Virtual DOM\"\n        title=\"\"\n        src=\"/static/1a3f8bfe49b335ad2c92cec36d198010/f058b/image.png\"\n        srcset=\"/static/1a3f8bfe49b335ad2c92cec36d198010/c26ae/image.png 158w,\n/static/1a3f8bfe49b335ad2c92cec36d198010/6bdcf/image.png 315w,\n/static/1a3f8bfe49b335ad2c92cec36d198010/f058b/image.png 630w,\n/static/1a3f8bfe49b335ad2c92cec36d198010/40601/image.png 945w,\n/static/1a3f8bfe49b335ad2c92cec36d198010/00d43/image.png 1000w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<figcaption>\n<p>출처 <a href=\"https://www.geeksforgeeks.org/reactjs-virtual-dom/\">GeeksforGeeks</a></p>\n</figcaption>\n</figure>\n<p>리액트는 DOM의 스냅샷인 Virtual DOM을 유지합니다<br>\n정확히는 두 개 유지하는데, New버전과 Old버전입니다</p>\n<p>어떤 state가 변하거나 해서 새로운 업데이트가 발생하면,<br>\n이 내용이 New Virtual DOM에 반영됩니다.<br>\n그럼 이제 Old VIrtual DOM과 이 업데이트 된 New Virtual DOM을 비교하고<br>\n변한 곳을 캐치해내고, 그 <strong>변한 지점만 실제 DOM에 반영하여 업데이트</strong>합니다.</p>\n<p>단지 그 뿐입니다</p>\n<h2 id=\"key\" style=\"position:relative;\"><a href=\"#key\" aria-label=\"key permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>key</h2>\n<p><code class=\"language-text\">list.map(item => &lt;li key={item}>{item}&lt;/li>) 이런거 해보셨을겁니다  \n이렇게 목록으로 여러 컴포넌트를 생성하는 경우 무조건 </code>key<code class=\"language-text\">속성이 명시되어야 합니다  \n알겠는데,</code>key`는 그래서 뭘까요?</p>\n<p>이름에서 짐작 가능하듯이, <code class=\"language-text\">key</code>는 <strong>컴포넌트의 각 인스턴스를 구별하는 식별자</strong>입니다<br>\n사실 <code class=\"language-text\">&lt;Foo /></code>같은거 여러번 써놓으면, 같은 함수 컴포넌트에서 찍어냈지만<br>\n각기 다른 인스턴스입니다. 상태값 같은 것들도 당연히 따로 갖고요<br>\n같은 설계도로 찍은 다른 결과물이라는 뜻인데<br>\n따라서 목록으로 찍어낼 때 이 각 인스턴스들을 구별하기 위한 <code class=\"language-text\">key</code>를 넣는 것입니다</p>\n<p>이 <code class=\"language-text\">key</code>는 또한, <strong>어떤 값이 바뀌면 해당 컴포넌트를 재삽입(다시 마운트)하고 싶을 때</strong> 사용해볼 수 있습니다<br>\n예를 들어, 어떤 <code class=\"language-text\">value</code>값이 변경되었다면, <code class=\"language-text\">&lt;Foo /></code> 컴포넌트를, 리렌더링 수준이 아니라 갈아끼우고 싶습니다<br>\n이런 경우 내부에서 <code class=\"language-text\">useEffect</code>를 쓸 수도 있겠지만, 간단히 <code class=\"language-text\">key</code>를 이용하면 해결됩니다<br>\n<code class=\"language-text\">&lt;Foo key={value} /></code> 이렇게요</p>\n<h2 id=\"state-scheduling-그리고-state-batching\" style=\"position:relative;\"><a href=\"#state-scheduling-%EA%B7%B8%EB%A6%AC%EA%B3%A0-state-batching\" aria-label=\"state scheduling 그리고 state batching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>State Scheduling, 그리고 State Batching</h2>\n<p><code class=\"language-text\">useState</code>훅에서 나오는 <code class=\"language-text\">setState()</code>함수는 <strong>비동기적</strong>입니다.<br>\n<code class=\"language-text\">setState()</code> 상태변화 함수를 만나는 순간! 함수컴포넌트 재실행!!<br>\n이게 아니고, 상태 변화를 <strong>예약</strong>할 뿐입니다</p>\n<p>그래서 아래같은 코드는 생각한 대로 흘러가지 않습니다</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">//원래 value값을 0으로 시작했다고 할 때</span>\n<span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//1?</span>\n<span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//2?</span></code></pre></div>\n<p>음.. 아마 결과는 1일걸요?<br>\nvalue+1이 연달아 일어나게 하려면 <code class=\"language-text\">setValue(prev => prev+1)</code>같이 상태변화함수로 해야합니다</p>\n<p>확실한건, 첫 번째 <code class=\"language-text\">setValue(value+1)</code> 줄 직후에 <code class=\"language-text\">value</code>는 업데이트되지 않습니다<br>\n언급했듯이 <code class=\"language-text\">setValue()</code>를 만난다고 해서 그 자리에서 바로 상태 값을 변경하지 않기 때문입니다<br>\n그렇게 하는 대신, React는 <code class=\"language-text\">setState</code>들을 긁어다가, 한 번에 처리합니다</p>\n<p>이렇게 상태 업데이트를 모아서 한 번에 처리하는 것을 <strong>State Batching</strong>이라고 합니다<br>\n이는 .. 함수 내의? 상태변화를 모두 모아서 처리한다고 해야할 것 같네요<br>\n공식문서에는 아래처럼 말합니다</p>\n<blockquote>\n<p><strong>React waits until <em>all</em> code in the event handlers has run before processing your state updates.</strong></p>\n</blockquote>\n<p>그리고 재미있는 것은, <a href=\"https://yozm.wishket.com/magazine/detail/2493/\">여기</a>에서 말하는 바와 같이<br>\nReact 17까지는 이 상태 배칭에 문제가 있었습니다<br>\nPromise나 setTimeout같이, 콜백으로 넘어가고 나면 이를 기다리지 않았기 떄문인데..<br>\n이후로는 그러한 경우까지 모두 커버되도록 해결되었다고 하네요</p>\n<h2 id=\"millionjs-패키지\" style=\"position:relative;\"><a href=\"#millionjs-%ED%8C%A8%ED%82%A4%EC%A7%80\" aria-label=\"millionjs 패키지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MillionJS 패키지</h2>\n<p><a href=\"https://million.dev/\">millionjs</a>는 리액트 성능 최적화를 위한 패키지인데<br>\n그냥 <code class=\"language-text\">npm install million</code>으로 설치하고, config파일에 적용해준 다음에<br>\n매뉴얼 따라서 실행해보면, cli에 <code class=\"language-text\">\"~~컴포넌트가 n% 빨라졌어요\"</code>같은게 뜹니다<br>\n내부적으로 Virtual DOM 업데이트를 최적화해주고, 다른 어쩌구저쩌구가 많은가본데<br>\n재밌어서 가져와봤습니다</p>\n<hr>\n<p>이만 마칩니다<br>\n.</p>","frontmatter":{"title":"96년차 개발자도 몰랐던 리액트 잡기술 (2)","date":"September 11, 2024","description":"지치지도 않고 찾아온 시리즈","tag":["TIL","React"]},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#useeffect%EC%97%90-%EB%8C%80%ED%95%B4\">useEffect에 대해</a></p>\n<ul>\n<li><a href=\"#useeffect-%ED%95%84%EC%9A%94%ED%95%9C-%EA%B2%BD%EC%9A%B0\">useEffect 필요한 경우?</a></li>\n<li><a href=\"#useeffect%EB%A1%9C-%ED%95%B4%EA%B2%B0\">useEffect로 해결</a></li>\n<li><a href=\"#%EA%B1%B0%EA%B8%B0%EC%84%A0-useeffect-%EC%93%B0%EC%A7%80-%EB%A7%88%EC%84%B8%EC%9A%94\">거기선 useEffect 쓰지 마세요</a></li>\n<li><a href=\"#clean-up-%ED%95%A8%EC%88%98\">clean up 함수</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#react%EA%B0%80-%ED%99%94%EB%A9%B4%EC%9D%84-%EA%B7%B8%EB%A6%AC%EB%8A%94-%EB%B9%84%EB%B0%80\">React가 화면을 그리는 비밀</a></p>\n<ul>\n<li><a href=\"#virtual-dom\">Virtual DOM</a></li>\n<li><a href=\"#key\">key</a></li>\n<li><a href=\"#state-scheduling-%EA%B7%B8%EB%A6%AC%EA%B3%A0-state-batching\">State Scheduling, 그리고 State Batching</a></li>\n<li><a href=\"#millionjs-%ED%8C%A8%ED%82%A4%EC%A7%80\">MillionJS 패키지</a></li>\n</ul>\n</li>\n</ul>"},"previous":{"fields":{"slug":"/til/react-life-hacks-1/"},"frontmatter":{"title":"96년차 개발자도 몰랐던 리액트 잡기술 (1)"}},"next":{"fields":{"slug":"/til/react-life-hacks-3/"},"frontmatter":{"title":"96년차 개발자도 모르는 리액트 잡기술 (3)"}}},"pageContext":{"id":"f39c37a6-8402-594f-ba50-594edd716f6c","previousPostId":"2bb04d61-8a16-5ec3-a736-364bbefe6212","nextPostId":"479330c5-f4fb-58ab-9c46-a87312afa02d"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}