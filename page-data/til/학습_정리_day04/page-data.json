{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/til/학습_정리_day04/","result":{"data":{"site":{"siteMetadata":{"title":"조성개발실록"}},"markdownRemark":{"id":"acd4f6c3-654b-523c-b2e5-153f832e4663","excerpt":"Partitioning Fixed Partitioning 처음부터 조각을 잘라두자. Equal-size : 모두 같은 사이즈로 컴파일 할 때도, \"나 여기서부터 시작한다!!\"를 미리 정하고 들어갈 수 있어서, Relocation…","html":"<h2 id=\"partitioning\" style=\"position:relative;\"><a href=\"#partitioning\" aria-label=\"partitioning permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Partitioning</h2>\n<h3 id=\"fixed-partitioning\" style=\"position:relative;\"><a href=\"#fixed-partitioning\" aria-label=\"fixed partitioning permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fixed Partitioning</h3>\n<p><strong>처음부터</strong> 조각을 잘라두자.</p>\n<ul>\n<li>Equal-size : 모두 같은 사이즈로\n<ul>\n<li>컴파일 할 때도, \"나 여기서부터 시작한다!!\"를 미리 정하고 들어갈 수 있어서, Relocation 문제를 걱정할 필요가 없다</li>\n<li>그런데, 조각들이 프로크램 사이즈에 딱 맞을 수는 없다. 공간 낭비가 생김</li>\n</ul>\n</li>\n<li>Unequal-size : 다양한 크기의 조각으로 나누자.\n<ul>\n<li>딱히 Equal-size보다 효율적이진 않음.</li>\n</ul>\n</li>\n<li>두 방식 모두, 어떤 식으로든, <strong>공간의 낭비</strong>가 생긴다 => <strong>Internal Fragmentation</strong></li>\n</ul>\n<h3 id=\"dynamic-partitioning\" style=\"position:relative;\"><a href=\"#dynamic-partitioning\" aria-label=\"dynamic partitioning permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamic Partitioning</h3>\n<p><strong>필요한 만큼</strong> 그때그때 잘라주자.</p>\n<ul>\n<li>미리 나눠두지 않는다 : 만약 56M만큼 빈공간이 있었는데,\n<ul>\n<li>20M 프로그램이 도착? 준다 => P1</li>\n<li>14M 프로그램이 도착? 준다 => P2</li>\n<li>18M 프로그램이 도착? 준다 => P3</li>\n<li>P2가 만약 Suspend되어 Swap-out : 중간에 14M 비었고, 밑에는 4M 비었다</li>\n<li>8M 프로그램 도착 ? 준다 => P4, 중간에 6M 구멍이 생겼다</li>\n</ul>\n</li>\n<li>위와 같이, 중간에 구멍이 나고, 구멍이 나고, => <strong>External Fragmentation</strong> 발생.</li>\n<li><strong>Compaction</strong>으로 해결 : 프로그램들을 위로 다 밀어붙이고, 공간을 병합한다\n<ul>\n<li>Dynamic Partitioning 쓰려면 주기적으로 이거 해줘야 한다</li>\n<li>근데 이거 하려면 각 프로세스가 차지하는 메모리를 한 줄 한 줄 주르륵.. 써야한다 : 메모리 <strong>읽기/쓰기</strong>를 엄청나게 하므로, 시간이 매우 오래걸리는 동작임</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"placement를-잘해봐요\" style=\"position:relative;\"><a href=\"#placement%EB%A5%BC-%EC%9E%98%ED%95%B4%EB%B4%90%EC%9A%94\" aria-label=\"placement를 잘해봐요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Placement를 잘해봐요</h4>\n<p><img src=\"https://i.imgur.com/2h3dWaR.png\" alt=\"\"></p>\n<ul>\n<li><strong><em>Best-fit</em></strong> : 위에서부터 <strong>가장 잘 맞는 공간</strong> 찾기. 16Mbyte면, 16Mbyte 이상이면서, 빈 공간을 최소로 하는 공간을 찾자.\n<ul>\n<li>근데 찾으려면, 모든 공간을 들춰봐야 함.. <strong>시간이 걸린다</strong></li>\n</ul>\n</li>\n<li><strong><em>First-fit</em></strong> : 가장 먼저 만나는 <strong>가능한 빈 공간</strong>에 넣자. 다 찾지 말고\n<ul>\n<li>빈 공간들을 링크드리스트로 연결해서 => 넣을 수 있는 공간을 탐색하기.</li>\n<li>공간을 찾는데 <strong>시간이 더 줄었으나, 빈 공간이 더 생긴다</strong></li>\n<li>또한, 앞에서부터 탐색하므로, <strong>앞쪽만 계속 조각나는 경향</strong>이 발생</li>\n</ul>\n</li>\n<li><strong><em>Next-fit</em></strong> : first-fit처럼 가능한 공간을 찾으면 끝이지만, 앞에서부터가 아니라 <strong>마지막으로 할당한 공간 다음부터 검색</strong>\n<ul>\n<li>앞쪽만 조각난다는 단점을 해결하고, 공간을 전체적으로 사용 => . first-fit에 비해 괜찮은 공간을 더 빨리 찾을 확률이 높다.</li>\n</ul>\n</li>\n<li><strong>Worst-fit</strong> : <strong>가장 큰 공간</strong>을 찾는다.\n<ul>\n<li>가장 큰 공간이므로, 프로세스 넣고도 충분히 큰 공간이겠지?</li>\n<li>이러면 오히려 external fragmentation을 줄이는 방법이 될 수 있겠지?</li>\n</ul>\n</li>\n</ul>\n<p>근데 당연히 이렇게 발버둥쳐도 external-fragmentation은 여전히 발생하고, compaction을 안 할 수는 없다</p>\n<h2 id=\"buddy-system\" style=\"position:relative;\"><a href=\"#buddy-system\" aria-label=\"buddy system permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Buddy System</h2>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≈</mo></mrow><annotation encoding=\"application/x-tex\">\\approx</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4831em;\"></span><span class=\"mrel\">≈</span></span></span></span></span> Lazy Segment Tree?</p>\n<p>fixed에서, 미리 잘라둔 공간에 프로세스를 넣고 남는 공간이 생김 : <strong>Internal Fragmentation</strong>\ndynamic에서, 프로세스 넣고 사이사이 남은 공간이 생김 : <strong>External Fragmentation</strong></p>\n<p><strong><em>Buddy System</em></strong> : 공간이 필요할 때마다 적당한 크기의 공간을 나눠줄건데(dynamic처럼), 프로세스가 요구하는 만큼 딱 맞추는게 아닌 정해진 규칙을 따른다 (fixed처럼)</p>\n<ul>\n<li><img src=\"https://i.imgur.com/dockjk4.png\" alt=\"\"></li>\n<li>전체 공간을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>U</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^U</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">U</span></span></span></span></span></span></span></span></span></span></span></span></li>\n<li>어떤 프로세서가 공간을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span>만큼 요구하면, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo>&#x3C;</mo><mi>S</mi><mo>&#x3C;</mo><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n-1 &#x3C; S &#x3C;= 2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7477em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&#x3C;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&#x3C;=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span> 일거고, 이 경우 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span>을 준다</li>\n<li>공간을 나눠주려면, 전체 메모리를 반으로, 반으로, 반으로, ... 자르다가 더 자르면 요구치보다 작아진다? 그러면 멈추고 현재 조각을 준다</li>\n<li>나눌 때마다, 나눈 결과인 두 조각은 <strong>버디</strong>가 된다. 공간을 병합할 때는 반드시 버디끼리.</li>\n<li>공간과 공간 사이의 External Fragmentation은 없고, 따라서 Compaction은 하지 않는다</li>\n<li>Internal Fragmentation은 발생할 수도 있긴 함</li>\n</ul>","frontmatter":{"title":"메모리 공간을 효율적으로 쓰고 싶어요","date":"July 19, 2024","description":"메모리 공간을 자르니까 자꾸 빈 공간이 남는데..","tag":["TIL","OS"]},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#partitioning\">Partitioning</a></p>\n<ul>\n<li>\n<p><a href=\"#fixed-partitioning\">Fixed Partitioning</a></p>\n</li>\n<li>\n<p><a href=\"#dynamic-partitioning\">Dynamic Partitioning</a></p>\n<ul>\n<li><a href=\"#placement%EB%A5%BC-%EC%9E%98%ED%95%B4%EB%B4%90%EC%9A%94\">Placement를 잘해봐요</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#buddy-system\">Buddy System</a></p>\n</li>\n</ul>"},"previous":{"fields":{"slug":"/til/학습_정리_day01/"},"frontmatter":{"title":"일일 학습정리 - Day01"}},"next":{"fields":{"slug":"/til/네이버_부스트캠프_1주차_회고/"},"frontmatter":{"title":"(네이버 부스트캠프 1주차) 나참 무슨 회고록을 쓰라고.."}}},"pageContext":{"id":"acd4f6c3-654b-523c-b2e5-153f832e4663","previousPostId":"055c8d8c-f1b8-5d9b-92f8-a4ad86557b6a","nextPostId":"a2691ee1-0243-5894-ad2c-5ff77386eeea"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}