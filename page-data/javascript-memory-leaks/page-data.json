{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/javascript-memory-leaks/","result":{"data":{"site":{"siteMetadata":{"title":"조성개발실록"}},"markdownRemark":{"id":"55623a6c-afa0-5905-b611-d824175046ca","excerpt":"최근에 Mantine이라는 오픈소스 프로젝트에 기여했는데요 이게 뭐냐면 회사에서 쓰는 React 컴포넌트 라이브러리입니다 Pokemon Mantine 이 글 쓰면서 알았는데 포켓몬 이름이었네요?? 진짜귀엽다만타인최고!!!!!!!!!!!!!!!!!! 암튼간에.. Mantine…","html":"<p>최근에 <a href=\"https://github.com/mantinedev/mantine\">Mantine</a>이라는 오픈소스 프로젝트에 기여했는데요<br>\n이게 뭐냐면 회사에서 쓰는 React 컴포넌트 라이브러리입니다</p>\n<figure>\n<p><img src=\"https://i.imgur.com/Rbe7FEo.png\" alt=\"Pokemon Mantine\"></p>\n<figcaption>\n만타인 - [포켓몬스터]\n</figcaption>\n</figure>\n<p>이 글 쓰면서 알았는데 포켓몬 이름이었네요?? 진짜귀엽다만타인최고!!!!!!!!!!!!!!!!!!</p>\n<p>암튼간에.. Mantine에서 <code class=\"language-text\">help needed</code> 라벨이 달린 이슈들을 살펴보다가<br>\n<a href=\"https://github.com/mantinedev/mantine/issues/7677\">Tree component retain references to detached DOM, leading to memory leak #7677</a> 이라는 이슈가 있었습니다<br>\nJavaScript에서 메모리 누수에 대해서 파본 적이 없지만 그래서인지 왠지 호승심이 드는 주제더라구여<br>\n그래서 아예 개념부터 시작해서 Bottom-Up 방식으로 들어가 함 해결해보고자 했습니다</p>\n<p>이번 글에서는</p>\n<ul>\n<li>먼저 배경지식으로 JavaScript에서의 메모리 관리에 대해 가볍게 알아보고</li>\n<li>저 이슈가 말하는 메모리 누수가 무슨 현상이고 어떻게 알 수 있는지 + 왜 그랬는지\n<ul>\n<li>이슈의 원인은 알고보니 별 시덥잖은 이유여서 기대하지는 않는게 좋습니다</li>\n</ul>\n</li>\n<li>Chrome Dev Tools에서 메모리를 프로파일링하기 위해 무엇을 알아야 할지</li>\n</ul>\n<p>등을 알아보겠습니다</p>\n<h1 id=\"배경지식-javascript의-메모리-관리\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EA%B2%BD%EC%A7%80%EC%8B%9D-javascript%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC\" aria-label=\"배경지식 javascript의 메모리 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배경지식: JavaScript의 메모리 관리</h1>\n<p>C언어같은 저수준 언어들은 <code class=\"language-text\">malloc()</code>과 <code class=\"language-text\">free()</code> 등의 함수로 개발자가 직접 메모리 할당과 해제를 관리합니다.</p>\n<p><img src=\"https://i.imgur.com/6bTqtFs.png\" alt=\"C malloc/free meme\"></p>\n<p>반면 JavaScript(같은 고수준 언어)는 객체가 생성되었을 때 자동으로 메모리를 할당하며, 필요하지 않아지면 자동으로 해제합니다.<br>\n이렇게 <strong>자동으로 메모리를 해제하는 메모리 관리 기법</strong>을 <strong>가비지 컬렉션(Garbage Collection, GC)</strong> 라고 합니다.</p>\n<p>대부분의 프로그래밍 언어에서 메모리 생존 주기는 다 비슷비슷한데,</p>\n<ol>\n<li>필요할 때 할당하고</li>\n<li>할당된 메모리를 사용(읽기/쓰기)하고</li>\n<li>더 이상 필요하지 않으면 해제한다.</li>\n</ol>\n<p>보통 이러는게 자연스러운 흐름입니다.<br>\n그리고 JavaScript같은 고수준 언어는 1번과 3번이 암묵적으로 동작한다는 이야기라고 봐야겠네요.<br>\n2번은 그냥 으레 하듯 코드 <small><del>싸는</del></small> 쓰는거구요</p>\n<p>메모리 할당에 대해 잠깐 살펴보면?</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> n <span class=\"token operator\">=</span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 정수를 담는 메모리 할당</span>\n<span class=\"token keyword\">const</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 문자열을 담는 메모리 할당</span>\n<span class=\"token keyword\">const</span> o <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">a</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 객체와 그 객체에 포함된 값들을 담는 메모리 할당</span>\n<span class=\"token comment\">// ... 이외에도 배열, 함수, 함수식 등 선언/할당</span></code></pre></div>\n<p>JavaScript에서는 이런 식으로 프로그래머가 무언가 값을 선언할 때 자동으로 메모리가 할당된다는 것이고<br>\n이외에도 <code class=\"language-text\">document.createElement(\"div\")</code> 처럼 함수 호출의 결과로 메모리가 할당될 수도 있는거고<br>\n아니면 <code class=\"language-text\">s2 = s.substr(0, 3)</code>처럼 메서드에 의해 새로운 값이나 오브젝트가 할당될 수도 있겠네요</p>\n<h2 id=\"메모리를-해제하기-가비지-컬렉션-garbage-collection\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%A5%BC-%ED%95%B4%EC%A0%9C%ED%95%98%EA%B8%B0-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98-garbage-collection\" aria-label=\"메모리를 해제하기 가비지 컬렉션 garbage collection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리를 해제하기: 가비지 컬렉션 (Garbage Collection)</h2>\n<p>물건을 꺼내서 사용한 다음에는 응당 다시 제자리에 두어야 하는데요<br>\n저는 제 방 하나 정리 못하지만 JavaScript에서는 가비지 컬렉터라고 해서 메모리 대신 치워주는 착한 친구가 있습니다<br>\n이 친구는 제 메모리들이 더 이상 필요하지 않으면 몰래 잘 정리해주는데요</p>\n<p>근데 <em>더 이상 필요하지 않은 메모리</em> 는 어떻게 알까요??</p>\n<p><img src=\"https://i.imgur.com/QWMQCJM.png\" alt=\"필요없어!\"></p>\n<p>아쉽게도 <em>더 이상 필요하지 않은</em> 이라는게 언제인지는 결정적인 문제가 아닙니다<br>\n제 머릿속을 들여다볼 수도 없고..<br>\n그래서 가비지 컬렉터들은 이 문제에 대한 근사적인 해결책을 구현합니다</p>\n<p>일단 가장 핵심적으로 쓰이는 개념은 <strong>참조</strong>(Reference)인데</p>\n<blockquote>\n<p>A라는 메모리를 통해 B라는 메모리에 접근할 수 있다면, \"B는 A에 의해 참조된다\"</p>\n</blockquote>\n<p>라고 생각해볼 수 있습니다.</p>\n<p><img src=\"https://i.imgur.com/zuCStwE.png\" alt=\"참조 관계\"></p>\n<p>이는 가비지 컬렉션의 핵심 개념이고,<br>\n모든 JavaScript 오브젝트는 <a href=\"https://developer.mozilla.org/ko/docs/Learn_web_development/Extensions/Advanced_JavaScript_objects/Object_prototypes\">prototype</a>을 통한 암시적 참조 및 그 객체의 property를 통한 명시적 참조를 가집니다.</p>\n<h3 id=\"1-reference-counting\" style=\"position:relative;\"><a href=\"#1-reference-counting\" aria-label=\"1 reference counting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Reference Counting</h3>\n<p><em>더 이상 필요하지 않다</em>를 판단하는 가장 단순한 방법 중 하나는 객체에 대한 <strong>참조를 세는 방법</strong>입니다.<br>\n어떤 객체를 참조하는 다른 객체들의 수를 세고,<br>\n그것이 0이면 <em>\"다른 어떤 객체도 참조하지 않는 객체\"</em> 이므로 이를 <strong>가비지</strong>(필요 없는 메모리)로 봅니다.</p>\n<p><img src=\"https://i.imgur.com/5vBmFR1.png\" alt=\"Reference Counting 예시\"></p>\n<p>대충 이런 식일까요?<br>\n근데 이러면 순환참조에서 문제가 생깁니다.<br>\n실제로는 어디에서도 사용되지 않지만, 서로가 서로에 대한 참조를 유지해버린다면..</p>\n<p><img src=\"https://i.imgur.com/DrnyQR9.png\" alt=\"Reference Counting에서의 순환참조 문제\"></p>\n<p><code class=\"language-text\">Reference Count: 1</code>로 0이 아니라서 수집할 수가 없습니다.<br>\n이는 Reference Counting 방식의 가비지 컬렉션에서 발생할 수 있는 메모리 누수의 흔한 원입니다.</p>\n<h3 id=\"2-mark-and-sweep\" style=\"position:relative;\"><a href=\"#2-mark-and-sweep\" aria-label=\"2 mark and sweep permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Mark and Sweep</h3>\n<p>참조를 세는 대신, 이번에는 <strong>\"도달할 수 없는 객체\"를 \"가비지\"로 정의</strong>해봅시다.<br>\n전역 객체인 <code class=\"language-text\">Root</code>를 두고, <code class=\"language-text\">Root</code>에서부터 도달 가능한지 여부를 봅니다.<br>\n<code class=\"language-text\">Root</code>에서 시작해서, <code class=\"language-text\">Root</code>가 직접 참조하는 객체, <code class=\"language-text\">Root</code>가 참조하는 객체가 참조하는 객체, ...</p>\n<p><img src=\"https://i.imgur.com/Y08xPkm.png\" alt=\"Mark and Sweep\"></p>\n<p><code class=\"language-text\">Root</code>에서부터의 순회로 <code class=\"language-text\">obj1, obj2, obj3, obj4</code>는 도달할 방법이 있지만,<br>\n<code class=\"language-text\">obj5, obj6</code>에는 도달할 방법이 존재하지 않으므로 가비지로 보고, 치워버립니다.</p>\n<p><img src=\"https://i.imgur.com/HTm0VOl.png\" alt=\"막다른 길\"></p>\n<p>수집하는 주기 등 세부 구현에서의 개선이나 차이가 있을 수 있지만, 현재 모든 최신 엔진들은 이 <strong>Mark-and-Sweep</strong> 방식을 기본으로 하여 가비지를 수집합니다.</p>\n<p>이외에도 JavaScript의 메모리 관리에 대해 더 살펴보시려면 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Memory_management\">JavaScript의 메모리 관리 from MDN</a> 문서를 참고하세요</p>\n<h1 id=\"아까-그-이슈는-뭐가-문제였나요\" style=\"position:relative;\"><a href=\"#%EC%95%84%EA%B9%8C-%EA%B7%B8-%EC%9D%B4%EC%8A%88%EB%8A%94-%EB%AD%90%EA%B0%80-%EB%AC%B8%EC%A0%9C%EC%98%80%EB%82%98%EC%9A%94\" aria-label=\"아까 그 이슈는 뭐가 문제였나요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아까 그 이슈는 뭐가 문제였나요?</h1>\n<p>처음에 언급한 Mantine의 <a href=\"https://github.com/mantinedev/mantine/issues/7677\">#7677</a> 이슈로 다시 돌아가봅시다.<br>\n무슨 내용이냐면, Mantine에는 <a href=\"https://mantine.dev/core/tree/\">Tree</a> 컴포넌트가 있는데</p>\n<p><img src=\"https://i.imgur.com/9kpjCER.gif\" alt=\"Mantine Tree Component\"></p>\n<p>계층이 있는 컴포넌트들을 하위에 숨겨뒀다가, 클릭해서 Expand하거나 Collapse할 수 있는 컴포넌트입니다만<br>\n이 Tree component를 열었다가 닫으면, 그 하위 Element들이 DOM에서 빠지면서 관련 메모리가 적절히 해제되어야 하지만<br>\n그렇지 않고 이 Element들에 대한 참조가 남아있어서 <strong>Detached DOM Element</strong>에 의한 <strong>Memory Leak</strong>이 발생한다<br>\n라는 내용입니다</p>\n<p><img src=\"https://i.imgur.com/6ScGbd3.png\" alt=\"#7677 이슈 일부\"></p>\n<p>이 이슈를 남긴 사람이 직접 남겨준 Bug Reprod. 내용인데</p>\n<ol>\n<li>Chrome DevTools (F12로 켜기) - Memory 탭에 들어가서, \"Detached Elements\" Profiling을 선택</li>\n<li>Tree 컴포넌트를 열었다가, 닫고</li>\n<li>스냅샷을 찍으면! 저렇게 나온다네요</li>\n</ol>\n<p>아쉽지만 지금은 저거랑 똑같이 Mantine Tree 컴포넌트 문서에 들어가도 확인할 길이 없어요<br>\n제가 고쳐놔서 ㅋㅋ;;<br>\n그리고 이렇게 <strong>메모리 누수가 발생하는 직접적인 원인은 React Dev Tools(Chrome Extension)</strong> 였습니다..</p>\n<p><img src=\"https://i.imgur.com/bHiAkPN.png\" alt=\"React Dev Tools\"></p>\n<p>React 개발자들이라면 주머니에 하나쯤 갖고게시는 이 확장프로그램 맞습니다</p>\n<p><img src=\"https://i.imgur.com/9tueRby.png\" alt=\"시무룩\"></p>\n<p>아무튼 처음 저 이슈를 파보기 시작했을 때 저는 메모리 패널에서의 모든게 생소했습니다<br>\n그래서 일단 크게 두 가지를 먼저 알아보고자 했는데<br>\n하나는 <strong>Detached DOM Elements가 뭐냐?</strong> 고<br>\n다른 하나는 <strong>Chrome DevTools의 Memory 탭에서 뭘 할 수 있나?</strong> 였습니다<br>\n이런 것들부터 시작해서 Bottom-Up 방식으로 메모리 누수에 대해 먼저 알고 해결을 시도했었네요</p>\n<h1 id=\"detached-dom-elements\" style=\"position:relative;\"><a href=\"#detached-dom-elements\" aria-label=\"detached dom elements permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Detached DOM Elements</h1>\n<p>DOM 노드(ex. <code class=\"language-text\">div</code>)는 DOM 트리 또는 JavaScript 코드에서 참조될 수 있습니다.<br>\n예를 들어, JavaScript에서는 아래와 같이 DOM 노드를 생성하고, DOM트리에 추가할 수 있습니다.<br>\n또는 DOM Tree에 존재하는 노드를 참조할 수도 있구요</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"div\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> bar <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nbar<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://i.imgur.com/M9hVRsF.png\" alt=\"DOM 노드에 대한 참조\"></p>\n<p>그런데 어떤 노드는 만들기만 하고 DOM Tree에 붙이지 않을 수도 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> baz <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"span\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// .. 그냥 만들었어요 ^^</span></code></pre></div>\n<p>아니면.. DOM Tree에서 제거했으나 여전히 JavaScript 변수에 의해 참조될 수도 있구요</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">bar<span class=\"token punctuation\">.</span><span class=\"token function\">removeChild</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// .. 그러나 foo는 여전히 div 요소를 참조함</span></code></pre></div>\n<p>이렇게 <strong>DOM 트리에 붙어있지 않지만 JavaScript에 의한 참조가 남아있는 요소</strong>를 <strong>Detached DOM Element</strong>라고 부릅니다.</p>\n<p><img src=\"https://i.imgur.com/EmKeAC6.png\" alt=\"DOM 노드에 대한 참조: detached DOM element\"></p>\n<p>이렇게 JavaScript에 의한 참조가 남아있는 경우 <strong>도달 가능</strong>하므로 가비지 컬렉팅의 대상이 되지 않습니다.<br>\n이는 곧 <strong>메모리를 해제할 수 없음</strong>을 의미하며 <strong>(잠재적인) 메모리 누수의 원인</strong>이 될 수 있습니다.</p>\n<h2 id=\"detached-dom-elements-를-발견하기\" style=\"position:relative;\"><a href=\"#detached-dom-elements-%EB%A5%BC-%EB%B0%9C%EA%B2%AC%ED%95%98%EA%B8%B0\" aria-label=\"detached dom elements 를 발견하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Detached DOM Elements 를 발견하기</h2>\n<p>Chrome Dev Tools에서 Detached DOM Elements가 남는지 확인할 수 있습니다.<br>\n먼저 F12같은거 눌러서 Chrome Dev Tools에 들어가고, \"<strong>메모리(Memory)</strong>\"탭으로 들어가봅니다.</p>\n<p><img src=\"https://i.imgur.com/dFJnlwx.png\" alt=\"Chrome Dev Tools 메모리탭\"></p>\n<p>여기에서 <code class=\"language-text\">Detached elements</code>를 선택하고, Take Snapshot을 찍어봅니다.</p>\n<p><img src=\"https://i.imgur.com/Rh17qk0.png\" alt=\"Detached elements 스냅샷 예시\"></p>\n<p>저는 크롬에서 \"새 탭\"누르면 나오는 그 기본페이지 거기서 찍어봤습니다\n여기에서는 Detached DOM Element의 정확한 HTML 생김새와 node count를 확인할 수 있습니다.</p>\n<p>이 <code class=\"language-text\">Detached elements</code> 스냅샷 말고도, 4가지 선택지 중 가장 위에 있던 <code class=\"language-text\">Heap snapshot</code>으로도 확인해볼 수 있습니다</p>\n<p><img src=\"https://i.imgur.com/hjUWcup.png\" alt=\"힙 스냅샷에서 Detached Element\"></p>\n<p>저는 여기서 가장 먼저 궁금했던 것은</p>\n<p><img src=\"https://i.imgur.com/ZyFDrUb.png\" alt=\"shallow size, retained size\"></p>\n<p>Shallow Size와 Retained Size 그리고 Distance였네요<br>\n이 용어들을 포함해서 힙 스냅샷 패널을 분석하는 법을 알아봐야겠으니 Chrome for Developers 문서를 읽기로 했습니다.<br>\n<a href=\"https://developer.chrome.com/docs/devtools/memory-problems/get-started?hl=ko\">메모리 용어</a>부터 시작합니다</p>\n<h1 id=\"메모리-용어와-프로파일링-그리고-문제-해결\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%9A%A9%EC%96%B4%EC%99%80-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%A7%81-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0\" aria-label=\"메모리 용어와 프로파일링 그리고 문제 해결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 용어와 프로파일링 그리고 문제 해결</h1>\n<p>메모리를 원시 자료형(숫자 및 문자열, 등)과 객체(연결이 있는 배열)가 있는 어떤 그래프로 생각해볼 수 있습니다.</p>\n<p><img src=\"https://i.imgur.com/LvOl7eo.png\" alt=\"메모리를 연결 그래프로 생각해보면..\"></p>\n<p>객체는 다음 두 가지 방법으로 메모리를 보유할 수 있는데:</p>\n<ul>\n<li>객체 자체에서 직접. - 명시적</li>\n<li>다른 객체에 대한 참조를 보유하여, 그 객체가 \"가비지\"가 되지 않도록 유지. - 암시적</li>\n</ul>\n<p>예를 들면 :</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">obj<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> <span class=\"token string\">\"fooo\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 객체 자체에 문자열을 위한 메모리를 가진다.</span>\nobj<span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> obj2<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 다른 객체를 참조한다 -> \"간접적으로 보유\"한다고 생각 가능</span></code></pre></div>\n<p>메모리를 보유하는 이 두 가지 방법이 Shallow Size와 Retained Size를 이해하는데 도움이 됩니다.</p>\n<h2 id=\"shallow-size-vs-retained-size\" style=\"position:relative;\"><a href=\"#shallow-size-vs-retained-size\" aria-label=\"shallow size vs retained size permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Shallow Size vs. Retained Size</h2>\n<p><strong>Shallow Size</strong>는 <strong>객체 자체에 보관되는 메모리의 크기</strong>를 나타냅니다.</p>\n<ul>\n<li>보통 JavaScript 객체는 본인에 대한 설명, 그리고 원시값들을 저장하기 위해 예약된 메모리를 가집니다.</li>\n<li>일반적으로 Shallow Size에서 상당한 크기를 차지할 수 있는 종류는 배열과 문자열 정도인데, 문자열과 외부 배열은 보통 <em>Renderer Memory</em>에 주로 저장되는 경우가 많으므로 JavaScript 힙에는 작은 <strong>Wrapper Object</strong>만이 남아있게 됩니다.</li>\n<li><strong>Renderer Memory</strong> = 페이지가 렌더링되는 프로세스의 <em>모든</em> 메모리를 일컫습니다.\n<ul>\n<li>Native 메모리 + 페이지의 JS 힙 메모리 + 페이지에서 시작된 모든 전용 worker의 JS 힙 메모리 + ...</li>\n</ul>\n</li>\n<li>명시적으로 보유한 메모리 크기라고 봐야겠네요.</li>\n</ul>\n<p><strong>Retained Size</strong>는 <strong>객체와 그 객체에 종속된 객체들이 GC Root에 의해 닿지 못하게 된 경우 해제될 총 메모리 크기</strong>를 나타냅니다.</p>\n<ul>\n<li><strong>GC Root</strong>? 브라우저에서 <code class=\"language-text\">window</code>객체, 또는 Node.js 모듈의 Global 객체, 또는 DOM Tree 등 ..</li>\n<li>메모리 그래프는 루트로부터 시작하며, 루트에서부터 순회하여 도달할 수 없으면 가비지 컬렉팅의 대상이 됩니다.</li>\n<li>암시적(간접적)으로 붙들고 있는 메모리 크기라고 봐야겠네요.</li>\n</ul>\n<p><img src=\"https://i.imgur.com/bJ8ngc6.png\" alt=\"Shallow Size vs. Retained Size\"></p>\n<p>특히 일반 JS객체처럼 보이지만, 실제로는 네이티브(C++) 엔진 레벨에 존재하며 JS에는 이 객체를 가리키는 <em>Wrapper Object</em>만이 노출되어있는 경우가 있습니다<br>\nDOM 노드(<code class=\"language-text\">HTMLDivElement</code>, <code class=\"language-text\">document.createElement(\"div\")</code>반환값, 등..)같은 친구들이 그러한데요<br>\n이런 친구들은 JavaScript 힙에 적재되지 않고, JavaScript에서는 이 네이티브 객체를 가리키는 Wrapper Object로만 액세스할 수 있습니다.<br>\n약간 빙산의 일각만 노출되어있고, 큰 부분은 다 네이티브 영역에 숨겨져 있다, 고 연상되네요</p>\n<p>그리고 이야기가 나와서 말인데, <strong>GC Root에서부터 객체까지 도달하기 위한 거리</strong>를 <strong>distance</strong>라고 부릅니다.<br>\n위에서 살짝 궁금했던 그 Distance 맞습니다.</p>\n<p><img src=\"https://i.imgur.com/qNIlZv7.png\" alt=\"Heap Snapshot Distance\"></p>\n<p>힙은 상호 연결된 객체의 네트워크라고 생각할 수 있으니 Distance라는 표현이 꽤 와닿긴 합니다</p>\n<p>JavaScript와 V8엔진에서의 메모리 용어에 대해 더 알고싶으시면</p>\n<ul>\n<li><a href=\"https://developer.chrome.com/docs/devtools/memory-problems/get-started?hl=en\">Memory Terminology - Chrome for Developers</a></li>\n<li><a href=\"https://v8.dev/blog/tracing-js-dom\">Tracing from JS to the DOM and back again - V8 Blog</a></li>\n</ul>\n<p>이런거 탐독해보세요. 아리까리한데 아무튼 재밌음</p>\n<h2 id=\"메모리-문제를-분석하고-해결하기\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%EB%B6%84%EC%84%9D%ED%95%98%EA%B3%A0-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0\" aria-label=\"메모리 문제를 분석하고 해결하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 문제를 분석하고 해결하기</h2>\n<p>Chrome Dev Tools의 메모리 패널로 다시 돌아가봅시다.</p>\n<p><img src=\"https://i.imgur.com/5T4ny8L.png\" alt=\"Chrome DevTools 메모리 패널\"></p>\n<h3 id=\"힙-스냅샷-찍기\" style=\"position:relative;\"><a href=\"#%ED%9E%99-%EC%8A%A4%EB%83%85%EC%83%B7-%EC%B0%8D%EA%B8%B0\" aria-label=\"힙 스냅샷 찍기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>힙 스냅샷 찍기</h3>\n<p>네 가지 라디오버튼 중 첫 번째인 <code class=\"language-text\">Heap Snapshot</code>은 페이지의 JS 객체와 관련 DOM 노드들 간의 메모리 분포를 보여줍니다.</p>\n<p>이 힙 스냅샷으로 Detached DOM Element에 의한 메모리 누수를 발견하는 방법을 보려고 합니다.<br>\n먼저 아래와 같이 아주 간단하게 Detached DOM Element를 만들어내봅니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"img\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://i.imgur.com/8CBxZ4o.png\" alt=\"간단한 Detached DOM Element 만들기\"></p>\n<p><code class=\"language-text\">&lt;img></code> 태그를 생성하여 JavaScript 참조를 만들고 DOM에는 추가하지 않았으므로 이 노드는 <strong>Detached</strong> 되어있습니다.</p>\n<p><img src=\"https://i.imgur.com/Kgm6tR9.png\" alt=\"길 잃은 펭귄\"></p>\n<p>DOM에 합류하지 못하고 길을 잃은 노드를 찾으러 가봅시다.<br>\nMemory 패널에서 <code class=\"language-text\">Take Snapshot</code>을 눌러 스냅샷을 남깁니다.</p>\n<p><img src=\"https://i.imgur.com/PP54zFO.png\" alt=\"힙 스냅샷 예시\"></p>\n<p>여기에서 방금 만든 <code class=\"language-text\">Detached &lt;img></code>를 찾아봅시다.<br>\n잘 안보이면 상단부의 <code class=\"language-text\">Filter by class</code>에 검색어를 입력하여 보고싶은 종류를 필터링할 수 있습니다.</p>\n<p><img src=\"https://i.imgur.com/nFyidzU.png\" alt=\"Detached img 찾기\"></p>\n<p>이런 식으로, <code class=\"language-text\">Detached</code>라고 입력하면 <code class=\"language-text\">Detached</code> 어쩌구만 나오니까 찾기 쉽습니다.<br>\n<code class=\"language-text\">Detached &lt;img></code>를 찾았으니 이거 함 눌러봅시다</p>\n<p><img src=\"https://i.imgur.com/WDjoPte.png\" alt=\"Detached 요소의 Retainers를 살펴보기\"></p>\n<p>누르면 네 개의 <code class=\"language-text\">Detached &lt;img></code>가 나왔는데, 제가 만든 것은 어떠한 attribute도 붙지 않은 <code class=\"language-text\">&lt;img></code>였으니 세 번째(<code class=\"language-text\">@41667</code>)네요</p>\n<p>이거 한번 눌러보면 아래 <code class=\"language-text\">Retainers</code> 패널에 뭔가 나오는데<br>\n여기에서는 해당 <strong>객체를 참조하는 코드</strong>에 관한 자세한 정보를 확인해볼 수 있습니다.<br>\n아까 만든 <code class=\"language-text\">foo</code>가 이 노드를 참조하고 있음을 알 수 있네요.</p>\n<figure>\n<p><img src=\"https://i.imgur.com/7pYuMB6.png\" alt=\"잡았다 요놈\"></p>\n<figcaption>\n<p><a href=\"https://comic.naver.com/webtoon/detail?titleId=163295&#x26;no=15&#x26;weekday=tue\">출처</a></p>\n</figcaption>\n</figure>\n<p>혹시 Node를 참조해놓고 까먹어서 메모리가 샌다면 이렇게라도 찾을 수 있겠습니다</p>\n<h3 id=\"할당-타임라인-녹화하기\" style=\"position:relative;\"><a href=\"#%ED%95%A0%EB%8B%B9-%ED%83%80%EC%9E%84%EB%9D%BC%EC%9D%B8-%EB%85%B9%ED%99%94%ED%95%98%EA%B8%B0\" aria-label=\"할당 타임라인 녹화하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>할당 타임라인 녹화하기</h3>\n<p><img src=\"https://i.imgur.com/2isaYHa.png\" alt=\"할당 타임라인 버튼\"></p>\n<p>이번에는 <code class=\"language-text\">Heap Snapshot</code> 대신에 <code class=\"language-text\">Allocations on timeline</code> 한번 선택해봅시다</p>\n<p><img src=\"https://i.imgur.com/49Biq3v.png\" alt=\"할당 타임라인 녹화중\"></p>\n<p>이런 식으로, 시간에 따른 JavaScript 메모리 할당을 관측할 수 있습니다.<br>\n이거 켜놓고 한 1000개정도 Detached Node를 만들어봅시다</p>\n<p><img src=\"https://i.imgur.com/g9XZNGJ.png\" alt=\"할당 타임라인에서 1000개 detached 요소 만들기\"></p>\n<p>5초정도 되는 타이밍에 아래 코드를 실행시켰습니다</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> x <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"div\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이제 5초 타이밍 전후로 범위를 줄여서, <code class=\"language-text\">Detached &lt;div></code> 1000개를 찾아봅시다</p>\n<p><img src=\"https://i.imgur.com/6wzBmZv.png\" alt=\"할당 타임라인에서 범위 좁혀서 원하는 할당 찾기\"></p>\n<p>1000개의 <code class=\"language-text\">Detached &lt;div></code>를 찾을 수 있었고, <code class=\"language-text\">x</code>라는 배열에서 이들을 참조한다는 것 까지 알 수 있네요<br>\n메모리 누수가 의심되는 동작이 있다면 할당 타임라인 녹화를 켜두고 그 동작을 트리거해봅시다.</p>\n<p><img src=\"https://i.imgur.com/Cf35wub.png\" alt=\"지켜보는 짤\"></p>\n<p>기록된 타임라인에서 그 동작이 트리거된 순간 어떤 메모리 할당이 일어나는지 진단해볼 수 있겠습니다</p>\n<h3 id=\"할당-샘플링\" style=\"position:relative;\"><a href=\"#%ED%95%A0%EB%8B%B9-%EC%83%98%ED%94%8C%EB%A7%81\" aria-label=\"할당 샘플링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>할당 샘플링</h3>\n<p><img src=\"https://i.imgur.com/rkeI59h.png\" alt=\"할당 샘플링 버튼\"></p>\n<p><code class=\"language-text\">Allocation sampling</code>에서는 각 JavaScript 스택별(함수별, 이라고 생각하면 편함) 메모리 할당을 샘플링할 수 있습니다.<br>\n이 샘플링은 성능 오버헤드를 최소한으로 유발하기 때문에 장기간 켜두며 정보를 수집해봐도 좋습니다.</p>\n<p>저는 할당 샘플링을 켠 채로 아래와 같은 간단한 함수를 만들고 1회 실행해보겠습니다</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> x <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">bar</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"div\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://i.imgur.com/QHoKHhN.png\" alt=\"할당 샘플링 결과\"></p>\n<p><code class=\"language-text\">bar()</code> 함수에 의해 <code class=\"language-text\">16.4KB</code>만큼의 할당이 있었네요.<br>\n<code class=\"language-text\">Self size</code>와 <code class=\"language-text\">Total size</code>는 제가 기억하기로는<br>\nself는 \"콜스택 자기 자신에 의한\"이고 total은 \"그 하위까지 포함\"입니다<br>\n<a href=\"/chrome-extension-performance-optimization/#%EA%B2%B0%EA%B3%BC%EB%8A%94\">웹 렌더링 성능 최적화</a>에 관한 글에서 <code class=\"language-text\">self</code>와 <code class=\"language-text\">total</code>에 대해 잠깐 다뤘었네요. 거기선 <code class=\"language-text\">time</code>이었지만</p>\n<h3 id=\"분리된-요소\" style=\"position:relative;\"><a href=\"#%EB%B6%84%EB%A6%AC%EB%90%9C-%EC%9A%94%EC%86%8C\" aria-label=\"분리된 요소 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>분리된 요소</h3>\n<p><img src=\"https://i.imgur.com/yzY8Xey.png\" alt=\"Detached elements 버튼\"></p>\n<p><code class=\"language-text\">Detached elements</code>는 위에서 한번 살펴봤었는데요<br>\n여기에서는 JavaScript 참조에 의해 유지되는 객체를 식별할 수 있습니다.</p>\n<p><img src=\"https://i.imgur.com/t46E9QU.png\" alt=\"Detached elements 결과 예시\"></p>\n<p>대충 이렇게 생겼었죠?<br>\nDetached DOM Elements가 발생했음을 가장 간단히 식별할 수 있는 방법이었습니다.</p>\n<hr>\n<h1 id=\"끝\" style=\"position:relative;\"><a href=\"#%EB%81%9D\" aria-label=\"끝 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>끝</h1>\n<p>이번 글에서는 <strong>JavaScript에서의 메모리 관리와 Chrome Dev Tools에서 메모리 누수</strong>(특히 <strong>Detached DOM Elements</strong>를 중심으로)를 진단하는 방법에 대해 다뤘습니다.<br>\nJavaScript 코드를 작성하는 입장에서 메모리에 대해 크게 신경쓰지 않는 경우가 있을 수 있는데<br>\n그러나 메모리 문제가 쌓이면 사용자가 인식할 수 있게 되는 경우가 많으므로 이를 식별하고 대처하는 일은 중요합니다.</p>\n<p><img src=\"https://i.imgur.com/76Cq2iI.png\" alt=\"답답하다 아주 그냥\"></p>\n<p>사용자가 아래와 같은 문제를 겪는다면 메모리 문제일 수 있습니다:</p>\n<ul>\n<li>페이지에서 <strong>시간이 지남에 따라 점점 성능이 저하</strong>됨 - 메모리 누수 가능성</li>\n<li>페이지의 <strong>성능이 지속적으로 나쁨</strong> - 메모리 팽창(필요 이상의 메모리를 사용하는 경우) 가능성</li>\n<li>페이지가 <strong>지연되거나 잠깐 일시정지되는 듯</strong> 보임 - 잦은 가비지 컬렉션의 영향일 가능성\n<ul>\n<li>가비지 컬렉션이 진행되는 중에는 모든 스크립트 실행이 중단되기 때문입니다.</li>\n</ul>\n</li>\n</ul>\n<p>사실은 이런 증상이 발견되기 전에 미리 신경써서 예방하거나 조기진압하는게 좋겠죠?</p>\n<p>이만 마칩니다</p>\n<h2 id=\"ref\" style=\"position:relative;\"><a href=\"#ref\" aria-label=\"ref permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ref.</h2>\n<p><a href=\"https://developer.chrome.com/docs/devtools/memory-problems/get-started?hl=ko\">메모리 용어 - Chrome for Developers</a><br>\n<a href=\"https://developer.chrome.com/docs/devtools/memory-problems?hl=ko\">메모리 문제 해결 - Chrome for Developers</a><br>\n<a href=\"https://developer.chrome.com/docs/devtools/memory-problems/heap-snapshots?hl=ko\">힙 스냅샷 기록 - Chrome for Developers</a><br>\n<a href=\"https://v8.dev/blog/tracing-js-dom\">Tracing from JS to the DOM and back again - V8 dev</a><br>\n<a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Memory_management\">JavaScript의 메모리 관리 - MDN</a><br>\n<a href=\"https://medium.com/@rahul.jindal57/memory-leaks-in-dom-elements-and-closures-b3452f129dac\">Memory Leaks in DOM Elements and Closures</a></p>","frontmatter":{"title":"🚰 29K+ Star 오픈소스에서 메모리가 줄줄 새는 원인 찾기 (JavaScript 메모리 누수)","date":"June 28, 2025","description":"JavaScript 메모리 관리, 그리고 Chrome Dev Tools에서 메모리 누수 진단하기 - Detached DOM Elements 위주로","tag":["JavaScript"]},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%B0%B0%EA%B2%BD%EC%A7%80%EC%8B%9D-javascript%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC\">배경지식: JavaScript의 메모리 관리</a></p>\n<ul>\n<li>\n<p><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%A5%BC-%ED%95%B4%EC%A0%9C%ED%95%98%EA%B8%B0-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98-garbage-collection\">메모리를 해제하기: 가비지 컬렉션 (Garbage Collection)</a></p>\n<ul>\n<li><a href=\"#1-reference-counting\">1. Reference Counting</a></li>\n<li><a href=\"#2-mark-and-sweep\">2. Mark and Sweep</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%95%84%EA%B9%8C-%EA%B7%B8-%EC%9D%B4%EC%8A%88%EB%8A%94-%EB%AD%90%EA%B0%80-%EB%AC%B8%EC%A0%9C%EC%98%80%EB%82%98%EC%9A%94\">아까 그 이슈는 뭐가 문제였나요?</a></p>\n</li>\n<li>\n<p><a href=\"#detached-dom-elements\">Detached DOM Elements</a></p>\n<ul>\n<li><a href=\"#detached-dom-elements-%EB%A5%BC-%EB%B0%9C%EA%B2%AC%ED%95%98%EA%B8%B0\">Detached DOM Elements 를 발견하기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%9A%A9%EC%96%B4%EC%99%80-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%A7%81-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0\">메모리 용어와 프로파일링 그리고 문제 해결</a></p>\n<ul>\n<li>\n<p><a href=\"#shallow-size-vs-retained-size\">Shallow Size vs. Retained Size</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%EB%B6%84%EC%84%9D%ED%95%98%EA%B3%A0-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0\">메모리 문제를 분석하고 해결하기</a></p>\n<ul>\n<li><a href=\"#%ED%9E%99-%EC%8A%A4%EB%83%85%EC%83%B7-%EC%B0%8D%EA%B8%B0\">힙 스냅샷 찍기</a></li>\n<li><a href=\"#%ED%95%A0%EB%8B%B9-%ED%83%80%EC%9E%84%EB%9D%BC%EC%9D%B8-%EB%85%B9%ED%99%94%ED%95%98%EA%B8%B0\">할당 타임라인 녹화하기</a></li>\n<li><a href=\"#%ED%95%A0%EB%8B%B9-%EC%83%98%ED%94%8C%EB%A7%81\">할당 샘플링</a></li>\n<li><a href=\"#%EB%B6%84%EB%A6%AC%EB%90%9C-%EC%9A%94%EC%86%8C\">분리된 요소</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%81%9D\">끝</a></p>\n<ul>\n<li><a href=\"#ref\">Ref.</a></li>\n</ul>\n</li>\n</ul>"},"previous":{"fields":{"slug":"/til/global-state-using-context-and-subscription/"},"frontmatter":{"title":"Context로 전역상태 만들어서 구독과 좋아요 알림설정까지"}},"next":null},"pageContext":{"id":"55623a6c-afa0-5905-b611-d824175046ca","previousPostId":"ec2b1cbe-79ba-5aaa-b6e4-367dff0b5428","nextPostId":null}},"staticQueryHashes":["2841359383"],"slicesMap":{}}