{"version":3,"file":"component---src-pages-postprocessing-demo-tsx-5dd69c8c18a261b45280.js","mappings":"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EAAI,KAC3BC,EAAI,GAAKC,EAAcF,EAAI,IAC3BC,EAAI,GAAKC,EAAcF,EAAI,IAC3BC,EAAI,IAAMC,EAAcF,EAAI,IAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,IAC5BC,EAAI,IAAMC,EAAcF,EAAI,IAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,IAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC,EAAI,IAAMC,EAAcF,EAAI,KAC5BC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","sources":["webpack://gatsby-starter-blog/./node_modules/three-stdlib/objects/GroundProjectedEnv.js","webpack://gatsby-starter-blog/./node_modules/three-stdlib/loaders/RGBELoader.js","webpack://gatsby-starter-blog/./node_modules/three-stdlib/node_modules/fflate/esm/browser.js","webpack://gatsby-starter-blog/./node_modules/three-stdlib/loaders/EXRLoader.js","webpack://gatsby-starter-blog/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-DuOPRGA4.js","webpack://gatsby-starter-blog/./node_modules/@monogrid/gainmap-js/dist/decode.js","webpack://gatsby-starter-blog/./node_modules/@react-three/drei/helpers/environment-assets.js","webpack://gatsby-starter-blog/./node_modules/@react-three/drei/helpers/deprecated.js","webpack://gatsby-starter-blog/./node_modules/@react-three/drei/core/useEnvironment.js","webpack://gatsby-starter-blog/./node_modules/@react-three/drei/core/Environment.js","webpack://gatsby-starter-blog/./node_modules/three-stdlib/misc/WebGL.js","webpack://gatsby-starter-blog/./node_modules/@react-three/postprocessing/dist/EffectComposer.js","webpack://gatsby-starter-blog/./node_modules/@react-three/postprocessing/dist/Selection.js","webpack://gatsby-starter-blog/./node_modules/@react-three/postprocessing/dist/util.js","webpack://gatsby-starter-blog/./node_modules/@react-three/postprocessing/dist/effects/Outline.js","webpack://gatsby-starter-blog/./node_modules/@react-three/postprocessing/dist/effects/ToneMapping.js","webpack://gatsby-starter-blog/./src/components/HouseViewer.tsx","webpack://gatsby-starter-blog/./src/pages/postprocessing-demo.tsx"],"sourcesContent":["import { Mesh, IcosahedronGeometry, ShaderMaterial, DoubleSide } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nconst isCubeTexture = (def) => def && def.isCubeTexture;\nclass GroundProjectedEnv extends Mesh {\n  constructor(texture, options) {\n    var _a, _b;\n    const isCubeMap = isCubeTexture(texture);\n    const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;\n    const cubeSize = w / 4;\n    const _lodMax = Math.floor(Math.log2(cubeSize));\n    const _cubeSize = Math.pow(2, _lodMax);\n    const width = 3 * Math.max(_cubeSize, 16 * 7);\n    const height = 4 * _cubeSize;\n    const defines = [\n      isCubeMap ? \"#define ENVMAP_TYPE_CUBE\" : \"\",\n      `#define CUBEUV_TEXEL_WIDTH ${1 / width}`,\n      `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`,\n      `#define CUBEUV_MAX_MIP ${_lodMax}.0`\n    ];\n    const vertexShader = (\n      /* glsl */\n      `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `\n    );\n    const fragmentShader = defines.join(\"\\n\") + /* glsl */\n    `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n        }\n        `;\n    const uniforms = {\n      map: { value: texture },\n      height: { value: (options == null ? void 0 : options.height) || 15 },\n      radius: { value: (options == null ? void 0 : options.radius) || 100 }\n    };\n    const geometry = new IcosahedronGeometry(1, 16);\n    const material = new ShaderMaterial({\n      uniforms,\n      fragmentShader,\n      vertexShader,\n      side: DoubleSide\n    });\n    super(geometry, material);\n  }\n  set radius(radius) {\n    this.material.uniforms.radius.value = radius;\n  }\n  get radius() {\n    return this.material.uniforms.radius.value;\n  }\n  set height(height) {\n    this.material.uniforms.height.value = height;\n  }\n  get height() {\n    return this.material.uniforms.height.value;\n  }\n}\nexport {\n  GroundProjectedEnv\n};\n//# sourceMappingURL=GroundProjectedEnv.js.map\n","import { DataTextureLoader, HalfFloatType, FloatType, DataUtils, LinearFilter } from \"three\";\nclass RGBELoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  }\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n  parse(buffer) {\n    const rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n      switch (rgbe_error_code) {\n        case rgbe_read_error:\n          throw new Error(\"THREE.RGBELoader: Read Error: \" + (msg || \"\"));\n        case rgbe_write_error:\n          throw new Error(\"THREE.RGBELoader: Write Error: \" + (msg || \"\"));\n        case rgbe_format_error:\n          throw new Error(\"THREE.RGBELoader: Bad File Format: \" + (msg || \"\"));\n        default:\n        case rgbe_memory_error:\n          throw new Error(\"THREE.RGBELoader: Memory Error: \" + (msg || \"\"));\n      }\n    }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer2, lineLimit, consume) {\n      const chunkSize = 128;\n      lineLimit = !lineLimit ? 1024 : lineLimit;\n      let p = buffer2.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength) {\n        s += chunk;\n        len += chunk.length;\n        p += chunkSize;\n        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n      }\n      if (-1 < i) {\n        if (false !== consume)\n          buffer2.pos += len + i + 1;\n        return s + chunk.slice(0, i);\n      }\n      return false;\n    }, RGBE_ReadHeader = function(buffer2) {\n      const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, header = {\n        valid: 0,\n        string: \"\",\n        comments: \"\",\n        programtype: \"RGBE\",\n        format: \"\",\n        gamma: 1,\n        exposure: 1,\n        width: 0,\n        height: 0\n      };\n      let line, match;\n      if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {\n        rgbe_error(rgbe_read_error, \"no header found\");\n      }\n      if (!(match = line.match(magic_token_re))) {\n        rgbe_error(rgbe_format_error, \"bad initial token\");\n      }\n      header.valid |= RGBE_VALID_PROGRAMTYPE;\n      header.programtype = match[1];\n      header.string += line + \"\\n\";\n      while (true) {\n        line = fgets(buffer2);\n        if (false === line)\n          break;\n        header.string += line + \"\\n\";\n        if (\"#\" === line.charAt(0)) {\n          header.comments += line + \"\\n\";\n          continue;\n        }\n        if (match = line.match(gamma_re)) {\n          header.gamma = parseFloat(match[1]);\n        }\n        if (match = line.match(exposure_re)) {\n          header.exposure = parseFloat(match[1]);\n        }\n        if (match = line.match(format_re)) {\n          header.valid |= RGBE_VALID_FORMAT;\n          header.format = match[1];\n        }\n        if (match = line.match(dimensions_re)) {\n          header.valid |= RGBE_VALID_DIMENSIONS;\n          header.height = parseInt(match[1], 10);\n          header.width = parseInt(match[2], 10);\n        }\n        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS)\n          break;\n      }\n      if (!(header.valid & RGBE_VALID_FORMAT)) {\n        rgbe_error(rgbe_format_error, \"missing format specifier\");\n      }\n      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n        rgbe_error(rgbe_format_error, \"missing image size specifier\");\n      }\n      return header;\n    }, RGBE_ReadPixels_RLE = function(buffer2, w2, h2) {\n      const scanline_width = w2;\n      if (\n        // run length encoding is not allowed so read flat\n        scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded\n        2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128\n      ) {\n        return new Uint8Array(buffer2);\n      }\n      if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {\n        rgbe_error(rgbe_format_error, \"wrong scanline width\");\n      }\n      const data_rgba = new Uint8Array(4 * w2 * h2);\n      if (!data_rgba.length) {\n        rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n      }\n      let offset = 0, pos = 0;\n      const ptr_end = 4 * scanline_width;\n      const rgbeStart = new Uint8Array(4);\n      const scanline_buffer = new Uint8Array(ptr_end);\n      let num_scanlines = h2;\n      while (num_scanlines > 0 && pos < buffer2.byteLength) {\n        if (pos + 4 > buffer2.byteLength) {\n          rgbe_error(rgbe_read_error);\n        }\n        rgbeStart[0] = buffer2[pos++];\n        rgbeStart[1] = buffer2[pos++];\n        rgbeStart[2] = buffer2[pos++];\n        rgbeStart[3] = buffer2[pos++];\n        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n          rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n        }\n        let ptr = 0, count;\n        while (ptr < ptr_end && pos < buffer2.byteLength) {\n          count = buffer2[pos++];\n          const isEncodedRun = count > 128;\n          if (isEncodedRun)\n            count -= 128;\n          if (0 === count || ptr + count > ptr_end) {\n            rgbe_error(rgbe_format_error, \"bad scanline data\");\n          }\n          if (isEncodedRun) {\n            const byteValue = buffer2[pos++];\n            for (let i = 0; i < count; i++) {\n              scanline_buffer[ptr++] = byteValue;\n            }\n          } else {\n            scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);\n            ptr += count;\n            pos += count;\n          }\n        }\n        const l = scanline_width;\n        for (let i = 0; i < l; i++) {\n          let off = 0;\n          data_rgba[offset] = scanline_buffer[i + off];\n          off += scanline_width;\n          data_rgba[offset + 1] = scanline_buffer[i + off];\n          off += scanline_width;\n          data_rgba[offset + 2] = scanline_buffer[i + off];\n          off += scanline_width;\n          data_rgba[offset + 3] = scanline_buffer[i + off];\n          offset += 4;\n        }\n        num_scanlines--;\n      }\n      return data_rgba;\n    };\n    const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2, e - 128) / 255;\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n      destArray[destOffset + 3] = 1;\n    };\n    const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2, e - 128) / 255;\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n      destArray[destOffset + 3] = DataUtils.toHalfFloat(1);\n    };\n    const byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    const rgbe_header_info = RGBE_ReadHeader(byteArray);\n    const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n    let data, type;\n    let numElements;\n    switch (this.type) {\n      case FloatType:\n        numElements = image_rgba_data.length / 4;\n        const floatArray = new Float32Array(numElements * 4);\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n        }\n        data = floatArray;\n        type = FloatType;\n        break;\n      case HalfFloatType:\n        numElements = image_rgba_data.length / 4;\n        const halfArray = new Uint16Array(numElements * 4);\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n        }\n        data = halfArray;\n        type = HalfFloatType;\n        break;\n      default:\n        throw new Error(\"THREE.RGBELoader: Unsupported type: \" + this.type);\n    }\n    return {\n      width: w,\n      height: h,\n      data,\n      header: rgbe_header_info.string,\n      gamma: rgbe_header_info.gamma,\n      exposure: rgbe_header_info.exposure,\n      type\n    };\n  }\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case FloatType:\n        case HalfFloatType:\n          if (\"colorSpace\" in texture)\n            texture.colorSpace = \"srgb-linear\";\n          else\n            texture.encoding = 3e3;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n      if (onLoad)\n        onLoad(texture, texData);\n    }\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n}\nexport {\n  RGBELoader\n};\n//# sourceMappingURL=RGBELoader.js.map\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([c], { type: 'text/javascript' }))));\n    w.onerror = function (e) { return cb(e.error, null); };\n    w.onmessage = function (e) { return cb(null, e.data); };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i)\n        ++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p / 8) | 0) + (p & 7 && 1); };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && !st.l && sl < 5))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                throw 'invalid block type';\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n            if (!c)\n                throw 'invalid length/literal';\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    throw 'invalid distance';\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            }\n            else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (t)\n            throw 'stream finished';\n        if (!strm.ondata)\n            throw 'no stream handler';\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        throw 'invalid gzip data';\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        throw 'invalid zlib data';\n    if (d[1] & 32)\n        throw 'invalid zlib data: preset dictionaries not supported';\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                throw 'invalid gzip stream';\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                throw 'invalid zlib stream';\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no stream handler';\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k;\n        if (val instanceof u8)\n            t[n] = [val, o];\n        else if (Array.isArray(val))\n            t[n] = [val[0], mrg(o, val[1])];\n        else\n            fltn(val, n + '/', t, o);\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    throw 'invalid utf-8 data';\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            throw 'stream finished';\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                throw 'invalid utf-8 data';\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        if (this.d)\n            throw 'stream finished';\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            throw 'invalid utf-8 data';\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                throw 'extra field too long';\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        throw 'date not in range 1980-2099';\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != null) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback - add to ZIP archive before pushing';\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (this.d & 2)\n            throw 'stream finished';\n        var f = strToU8(file.filename), fl = f.length;\n        var com = file.comment, o = com && strToU8(com);\n        var u = fl != file.filename.length || (o && (com.length != o.length));\n        var hl = fl + exfl(file.extra) + 30;\n        if (fl > 65535)\n            throw 'filename too long';\n        var header = new u8(hl);\n        wzh(header, 0, file, f, u);\n        var chks = [header];\n        var pAll = function () {\n            for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function () {\n                if (file.terminate)\n                    file.terminate();\n            },\n            r: function () {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt)\n                        nxt.r();\n                    else\n                        _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function (err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            }\n            else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new u8(16);\n                    wbytes(dd, 0, 0x8074B50);\n                    wbytes(dd, 4, file.crc);\n                    wbytes(dd, 8, cl);\n                    wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr)\n                        uf.r();\n                    tr = 1;\n                }\n                else if (tr)\n                    pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1)\n                throw 'stream finishing';\n            throw 'stream finished';\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl('filename too long', null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            throw 'filename too long';\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            throw 'no callback';\n        if (!this.p)\n            throw 'stream finished';\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    throw 'no callback';\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        throw 'unknown compression type ' + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                throw 'invalid zip file';\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */\nexport function unzip(data, cb) {\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cb('invalid zip file', null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft)\n        cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) {\n            cb('invalid zip file', null);\n            return;\n        }\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_3 = function (i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                files[fn] = d;\n                if (!--lft)\n                    cb(null, files);\n            }\n        };\n        if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                }\n                catch (e) {\n                    cbl(e, null);\n                }\n            }\n            else\n                term.push(inflate(infl, { size: su }, cbl));\n        }\n        else\n            cbl('unknown compression type ' + c_1, null);\n    };\n    for (var i = 0; i < c; ++i) {\n        _loop_3(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */\nexport function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            throw 'invalid zip file';\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50)\n            throw 'invalid zip file';\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2)\n            files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n            files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else\n            throw 'unknown compression type ' + c_2;\n    }\n    return files;\n}\n","import { DataTextureLoader, HalfFloatType, FloatType, RGBAFormat, RedFormat, LinearFilter, DataUtils } from \"three\";\nimport { unzlibSync } from \"fflate\";\nimport { version } from \"../_polyfill/constants.js\";\nconst hasColorSpace = version >= 152;\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  }\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16;\n    const HUF_DECBITS = 14;\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n    const HUF_DECSIZE = 1 << HUF_DECBITS;\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n      var n = k - 1;\n      while (k < USHORT_RANGE)\n        lut[k++] = 0;\n      return n;\n    }\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n    const getBitsReturn = { l: 0, c: 0, lc: 0 };\n    function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n        lc += 8;\n      }\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n    const hufTableBuffer = new Array(59);\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i)\n        hufTableBuffer[i] = 0;\n      for (var i = 0; i < HUF_ENCSIZE; ++i)\n        hufTableBuffer[hcode[i]] += 1;\n      var c = 0;\n      for (var i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0)\n          hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n    function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni)\n          return false;\n        getBits(6, c, lc, uInt8Array2, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          getBits(8, c, lc, uInt8Array2, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--)\n            hcode[im++] = 0;\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--)\n            hcode[im++] = 0;\n          im--;\n        }\n      }\n      hufCanonicalCodeTable(hcode);\n    }\n    function hufLength(code) {\n      return code & 63;\n    }\n    function hufCode(code) {\n      return code >> 6;\n    }\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n        if (c >> l) {\n          throw \"Invalid table entry\";\n        }\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n          if (pl.len) {\n            throw \"Invalid table entry\";\n          }\n          pl.lit++;\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n          for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n            if (pl.len || pl.p) {\n              throw \"Invalid table entry\";\n            }\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n      return true;\n    }\n    const getCharReturn = { c: 0, lc: 0 };\n    function getChar(c, lc, uInt8Array2, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n    const getCodeReturn = { c: 0, lc: 0 };\n    function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array2, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n        var s = outBuffer[outBufferOffset.value - 1];\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n    function UInt16(value) {\n      return value & 65535;\n    }\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 32767 ? ref - 65536 : ref;\n    }\n    const wdec14Return = { a: 0, b: 0 };\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n    function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n      while (p <= n)\n        p <<= 1;\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n            if (w14) {\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            }\n          }\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14)\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n            else\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p10 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14)\n              wdec14(buffer2[px + j], buffer2[p01 + j]);\n            else\n              wdec16(buffer2[px + j], buffer2[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p01 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        p2 = p;\n        p >>= 1;\n      }\n      return py;\n    }\n    function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array2, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw \"hufDecode issues\";\n            }\n            var j;\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array2,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset\n                  );\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n            if (j == pl.lit) {\n              throw \"hufDecode issues\";\n            }\n          }\n        }\n      }\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw \"hufDecode issues\";\n        }\n      }\n      return true;\n    }\n    function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw \"Something wrong with HUF_ENCSIZE\";\n      }\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw \"Something wrong with hufUncompress\";\n      }\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n      while (true) {\n        if (s > stop)\n          break;\n        out[s++] = source[t1++];\n        if (s > stop)\n          break;\n        out[s++] = source[t2++];\n      }\n    }\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n      return out;\n    }\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8);\n      var numBlocksX = Math.ceil(width / 8);\n      var numBlocksY = Math.ceil(height / 8);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = { value: 0 };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n      for (let comp2 = 0; comp2 < numComp; ++comp2) {\n        rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n        currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n        dctData[comp2] = new Float32Array(64);\n        halfZigBlock[comp2] = new Uint16Array(64);\n        rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n      }\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1)\n          maxY = leftoverY;\n        var maxX = 8;\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1)\n            maxX = leftoverX;\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            halfZigBlock[comp2].fill(0);\n            halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n            unZigZag(halfZigBlock[comp2], dctData[comp2]);\n            dctInverse(dctData[comp2]);\n          }\n          {\n            csc709Inverse(dctData);\n          }\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n          }\n        }\n        let offset2 = 0;\n        for (let comp2 = 0; comp2 < numComp; ++comp2) {\n          const type2 = channelData[cscSet.idx[comp2]].type;\n          for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n            offset2 = rowOffsets[comp2][y2];\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y2 & 7) * 8;\n              dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n              dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n              dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n              dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n              dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n              dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n              dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n              dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n              offset2 += 8 * INT16_SIZE * type2;\n            }\n          }\n          if (numFullBlocksX != numBlocksX) {\n            for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n              const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n              const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n              for (let x2 = 0; x2 < maxX; ++x2) {\n                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n              }\n            }\n          }\n        }\n      }\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer);\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2)\n          continue;\n        for (var y = 0; y < height; ++y) {\n          const offset2 = rowOffsets[comp][y];\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n          }\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n        if (acValue == 65280) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 255) {\n          dctComp += acValue & 255;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n        currAcComp.value++;\n      }\n    }\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4);\n      const b = 0.5 * Math.cos(3.14159 / 16);\n      const c = 0.5 * Math.cos(3.14159 / 8);\n      const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n      const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n      const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n      const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n      }\n    }\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = { value: info.offset.value };\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n      var bitmap = new Uint8Array(BITMAP_SIZE);\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i][\"start\"] = outBufferEnd;\n        pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n        pizChannelData[i][\"nx\"] = info.width;\n        pizChannelData[i][\"ny\"] = info.lines;\n        pizChannelData[i][\"size\"] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      }\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n      }\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      }\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset);\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      }\n      applyLut(lut, outBuffer, outBufferEnd);\n      var tmpOffset2 = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset2);\n          tmpOffset2 += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n          }\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = { value: info.offset.value };\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n      if (dwaHeader.version < 2) {\n        throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n      }\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name,\n          index,\n          type,\n          compression\n        });\n        ruleSize -= name.length + 3;\n      }\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n      var cscSet = {\n        idx: new Array(3)\n      };\n      for (var offset2 = 0; offset2 < info.channels; ++offset2) {\n        var cd = channelData[offset2];\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset2;\n            }\n            cd.offset = offset2;\n          }\n        }\n      }\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount\n            );\n            break;\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = unzlibSync(compressed);\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      }\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      }\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = unzlibSync(compressed);\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      }\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      }\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded)\n          continue;\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n                rleOffset++;\n              }\n              row++;\n            }\n            break;\n          case LOSSY_DCT:\n          default:\n            throw \"EXRLoader.parse: unsupported channel compression\";\n        }\n      }\n      return new DataView(outBuffer.buffer);\n    }\n    function parseNullTerminatedString(buffer2, offset2) {\n      var uintBuffer = new Uint8Array(buffer2);\n      var endOffset = 0;\n      while (uintBuffer[offset2.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n      offset2.value = offset2.value + endOffset + 1;\n      return stringValue;\n    }\n    function parseFixedLengthString(buffer2, offset2, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n      offset2.value = offset2.value + size;\n      return stringValue;\n    }\n    function parseRational(dataView, offset2) {\n      var x = parseInt32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseTimecode(dataView, offset2) {\n      var x = parseUint32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseInt32(dataView, offset2) {\n      var Int32 = dataView.getInt32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Int32;\n    }\n    function parseUint32(dataView, offset2) {\n      var Uint32 = dataView.getUint32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Uint32;\n    }\n    function parseUint8Array(uInt8Array2, offset2) {\n      var Uint8 = uInt8Array2[offset2.value];\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    function parseUint8(dataView, offset2) {\n      var Uint8 = dataView.getUint8(offset2.value);\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    const parseInt64 = function(dataView, offset2) {\n      let int;\n      if (\"getBigInt64\" in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset2.value, true));\n      } else {\n        int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n      }\n      offset2.value += ULONG_SIZE;\n      return int;\n    };\n    function parseFloat32(dataView, offset2) {\n      var float = dataView.getFloat32(offset2.value, true);\n      offset2.value += FLOAT32_SIZE;\n      return float;\n    }\n    function decodeFloat32(dataView, offset2) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n    }\n    function decodeFloat16(binary) {\n      var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n    }\n    function parseUint16(dataView, offset2) {\n      var Uint16 = dataView.getUint16(offset2.value, true);\n      offset2.value += INT16_SIZE;\n      return Uint16;\n    }\n    function parseFloat16(buffer2, offset2) {\n      return decodeFloat16(parseUint16(buffer2, offset2));\n    }\n    function parseChlist(dataView, buffer2, offset2, size) {\n      var startOffset = offset2.value;\n      var channels = [];\n      while (offset2.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer2, offset2);\n        var pixelType = parseInt32(dataView, offset2);\n        var pLinear = parseUint8(dataView, offset2);\n        offset2.value += 3;\n        var xSampling = parseInt32(dataView, offset2);\n        var ySampling = parseInt32(dataView, offset2);\n        channels.push({\n          name,\n          pixelType,\n          pLinear,\n          xSampling,\n          ySampling\n        });\n      }\n      offset2.value += 1;\n      return channels;\n    }\n    function parseChromaticities(dataView, offset2) {\n      var redX = parseFloat32(dataView, offset2);\n      var redY = parseFloat32(dataView, offset2);\n      var greenX = parseFloat32(dataView, offset2);\n      var greenY = parseFloat32(dataView, offset2);\n      var blueX = parseFloat32(dataView, offset2);\n      var blueY = parseFloat32(dataView, offset2);\n      var whiteX = parseFloat32(dataView, offset2);\n      var whiteY = parseFloat32(dataView, offset2);\n      return {\n        redX,\n        redY,\n        greenX,\n        greenY,\n        blueX,\n        blueY,\n        whiteX,\n        whiteY\n      };\n    }\n    function parseCompression(dataView, offset2) {\n      var compressionCodes = [\n        \"NO_COMPRESSION\",\n        \"RLE_COMPRESSION\",\n        \"ZIPS_COMPRESSION\",\n        \"ZIP_COMPRESSION\",\n        \"PIZ_COMPRESSION\",\n        \"PXR24_COMPRESSION\",\n        \"B44_COMPRESSION\",\n        \"B44A_COMPRESSION\",\n        \"DWAA_COMPRESSION\",\n        \"DWAB_COMPRESSION\"\n      ];\n      var compression = parseUint8(dataView, offset2);\n      return compressionCodes[compression];\n    }\n    function parseBox2i(dataView, offset2) {\n      var xMin = parseUint32(dataView, offset2);\n      var yMin = parseUint32(dataView, offset2);\n      var xMax = parseUint32(dataView, offset2);\n      var yMax = parseUint32(dataView, offset2);\n      return { xMin, yMin, xMax, yMax };\n    }\n    function parseLineOrder(dataView, offset2) {\n      var lineOrders = [\"INCREASING_Y\"];\n      var lineOrder = parseUint8(dataView, offset2);\n      return lineOrders[lineOrder];\n    }\n    function parseV2f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      return [x, y];\n    }\n    function parseV3f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      var z = parseFloat32(dataView, offset2);\n      return [x, y, z];\n    }\n    function parseValue(dataView, buffer2, offset2, type, size) {\n      if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n        return parseFixedLengthString(buffer2, offset2, size);\n      } else if (type === \"chlist\") {\n        return parseChlist(dataView, buffer2, offset2, size);\n      } else if (type === \"chromaticities\") {\n        return parseChromaticities(dataView, offset2);\n      } else if (type === \"compression\") {\n        return parseCompression(dataView, offset2);\n      } else if (type === \"box2i\") {\n        return parseBox2i(dataView, offset2);\n      } else if (type === \"lineOrder\") {\n        return parseLineOrder(dataView, offset2);\n      } else if (type === \"float\") {\n        return parseFloat32(dataView, offset2);\n      } else if (type === \"v2f\") {\n        return parseV2f(dataView, offset2);\n      } else if (type === \"v3f\") {\n        return parseV3f(dataView, offset2);\n      } else if (type === \"int\") {\n        return parseInt32(dataView, offset2);\n      } else if (type === \"rational\") {\n        return parseRational(dataView, offset2);\n      } else if (type === \"timecode\") {\n        return parseTimecode(dataView, offset2);\n      } else if (type === \"preview\") {\n        offset2.value += size;\n        return \"skipped\";\n      } else {\n        offset2.value += size;\n        return void 0;\n      }\n    }\n    function parseHeader(dataView, buffer2, offset2) {\n      const EXRHeader2 = {};\n      if (dataView.getUint32(0, true) != 20000630) {\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n      }\n      EXRHeader2.version = dataView.getUint8(4);\n      const spec = dataView.getUint8(5);\n      EXRHeader2.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16)\n      };\n      offset2.value = 8;\n      var keepReading = true;\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer2, offset2);\n        if (attributeName == 0) {\n          keepReading = false;\n        } else {\n          var attributeType = parseNullTerminatedString(buffer2, offset2);\n          var attributeSize = parseUint32(dataView, offset2);\n          var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n          if (attributeValue === void 0) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n          } else {\n            EXRHeader2[attributeName] = attributeValue;\n          }\n        }\n      }\n      if ((spec & ~4) != 0) {\n        console.error(\"EXRHeader:\", EXRHeader2);\n        throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n      }\n      return EXRHeader2;\n    }\n    function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n      const EXRDecoder2 = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array2,\n        offset: offset2,\n        width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n        height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n        channels: EXRHeader2.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader2.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? \"colorSpace\" : \"encoding\"]: null\n      };\n      switch (EXRHeader2.compression) {\n        case \"NO_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRAW;\n          break;\n        case \"RLE_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRLE;\n          break;\n        case \"ZIPS_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"ZIP_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"PIZ_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressPIZ;\n          break;\n        case \"PXR24_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressPXR;\n          break;\n        case \"DWAA_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        case \"DWAB_COMPRESSION\":\n          EXRDecoder2.lines = 256;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        default:\n          throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n      }\n      EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n      if (EXRDecoder2.type == 1) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = parseUint16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n        }\n      } else if (EXRDecoder2.type == 2) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = decodeFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n        }\n      } else {\n        throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n      }\n      EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n      for (var i = 0; i < EXRDecoder2.blockCount; i++)\n        parseInt64(dataView, offset2);\n      EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n      const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder2.byteArray = new Float32Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)\n            EXRDecoder2.byteArray.fill(1, 0, size);\n          break;\n        case HalfFloatType:\n          EXRDecoder2.byteArray = new Uint16Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)\n            EXRDecoder2.byteArray.fill(15360, 0, size);\n          break;\n        default:\n          console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n          break;\n      }\n      EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n      if (EXRDecoder2.outputChannels == 4)\n        EXRDecoder2.format = RGBAFormat;\n      else\n        EXRDecoder2.format = RedFormat;\n      if (hasColorSpace)\n        EXRDecoder2.colorSpace = \"srgb-linear\";\n      else\n        EXRDecoder2.encoding = 3e3;\n      return EXRDecoder2;\n    }\n    const bufferDataView = new DataView(buffer);\n    const uInt8Array = new Uint8Array(buffer);\n    const offset = { value: 0 };\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n    const tmpOffset = { value: 0 };\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 };\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n      const line = parseUint32(bufferDataView, offset);\n      EXRDecoder.size = parseUint32(bufferDataView, offset);\n      EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n      offset.value += EXRDecoder.size;\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n        if (true_y >= EXRDecoder.height)\n          break;\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n            const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n          }\n        }\n      }\n    }\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? \"colorSpace\" : \"encoding\"]: EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"],\n      type: this.type\n    };\n  }\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace)\n        texture.colorSpace = texData.colorSpace;\n      else\n        texture.encoding = texData.encoding;\n      texture.minFilter = LinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.flipY = false;\n      if (onLoad)\n        onLoad(texture, texData);\n    }\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n}\nexport {\n  EXRLoader\n};\n//# sourceMappingURL=EXRLoader.js.map\n","/**\n * @monogrid/gainmap-js v3.1.0\n * With ❤️, by MONOGRID <rnd@monogrid.com>\n */\n\nimport { RGBAFormat, LinearFilter, ClampToEdgeWrapping, Scene, OrthographicCamera, HalfFloatType, FloatType, Mesh, PlaneGeometry, WebGLRenderTarget, UVMapping, WebGLRenderer, DataTexture, LinearSRGBColorSpace, ShaderMaterial, Texture, IntType, ShortType, ByteType, UnsignedIntType, UnsignedByteType, MeshBasicMaterial } from 'three';\n\nconst getBufferForType = (type, width, height) => {\n    let out;\n    switch (type) {\n        case UnsignedByteType:\n            out = new Uint8ClampedArray(width * height * 4);\n            break;\n        case HalfFloatType:\n            out = new Uint16Array(width * height * 4);\n            break;\n        case UnsignedIntType:\n            out = new Uint32Array(width * height * 4);\n            break;\n        case ByteType:\n            out = new Int8Array(width * height * 4);\n            break;\n        case ShortType:\n            out = new Int16Array(width * height * 4);\n            break;\n        case IntType:\n            out = new Int32Array(width * height * 4);\n            break;\n        case FloatType:\n            out = new Float32Array(width * height * 4);\n            break;\n        default:\n            throw new Error('Unsupported data type');\n    }\n    return out;\n};\nlet _canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */\nconst canReadPixels = (type, renderer, camera, renderTargetOptions) => {\n    if (_canReadPixelsResult !== undefined)\n        return _canReadPixelsResult;\n    const testRT = new WebGLRenderTarget(1, 1, renderTargetOptions);\n    renderer.setRenderTarget(testRT);\n    const mesh = new Mesh(new PlaneGeometry(), new MeshBasicMaterial({ color: 0xffffff }));\n    renderer.render(mesh, camera);\n    renderer.setRenderTarget(null);\n    const out = getBufferForType(type, testRT.width, testRT.height);\n    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n    testRT.dispose();\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    _canReadPixelsResult = out[0] !== 0;\n    return _canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */\nclass QuadRenderer {\n    /**\n     * Constructs a new QuadRenderer\n     *\n     * @param options Parameters for this QuadRenderer\n     */\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n        this._rendererIsDisposable = false;\n        this._supportsReadPixels = true;\n        /**\n         * Renders the input texture using the specified material\n         */\n        this.render = () => {\n            this._renderer.setRenderTarget(this._renderTarget);\n            try {\n                this._renderer.render(this._scene, this._camera);\n            }\n            catch (e) {\n                this._renderer.setRenderTarget(null);\n                throw e;\n            }\n            this._renderer.setRenderTarget(null);\n        };\n        this._width = options.width;\n        this._height = options.height;\n        this._type = options.type;\n        this._colorSpace = options.colorSpace;\n        const rtOptions = {\n            // fixed options\n            format: RGBAFormat,\n            depthBuffer: false,\n            stencilBuffer: false,\n            // user options\n            type: this._type, // set in class property\n            colorSpace: this._colorSpace, // set in class property\n            anisotropy: ((_a = options.renderTargetOptions) === null || _a === void 0 ? void 0 : _a.anisotropy) !== undefined ? (_b = options.renderTargetOptions) === null || _b === void 0 ? void 0 : _b.anisotropy : 1,\n            generateMipmaps: ((_c = options.renderTargetOptions) === null || _c === void 0 ? void 0 : _c.generateMipmaps) !== undefined ? (_d = options.renderTargetOptions) === null || _d === void 0 ? void 0 : _d.generateMipmaps : false,\n            magFilter: ((_e = options.renderTargetOptions) === null || _e === void 0 ? void 0 : _e.magFilter) !== undefined ? (_f = options.renderTargetOptions) === null || _f === void 0 ? void 0 : _f.magFilter : LinearFilter,\n            minFilter: ((_g = options.renderTargetOptions) === null || _g === void 0 ? void 0 : _g.minFilter) !== undefined ? (_h = options.renderTargetOptions) === null || _h === void 0 ? void 0 : _h.minFilter : LinearFilter,\n            samples: ((_j = options.renderTargetOptions) === null || _j === void 0 ? void 0 : _j.samples) !== undefined ? (_k = options.renderTargetOptions) === null || _k === void 0 ? void 0 : _k.samples : undefined,\n            wrapS: ((_l = options.renderTargetOptions) === null || _l === void 0 ? void 0 : _l.wrapS) !== undefined ? (_m = options.renderTargetOptions) === null || _m === void 0 ? void 0 : _m.wrapS : ClampToEdgeWrapping,\n            wrapT: ((_o = options.renderTargetOptions) === null || _o === void 0 ? void 0 : _o.wrapT) !== undefined ? (_p = options.renderTargetOptions) === null || _p === void 0 ? void 0 : _p.wrapT : ClampToEdgeWrapping\n        };\n        this._material = options.material;\n        if (options.renderer) {\n            this._renderer = options.renderer;\n        }\n        else {\n            this._renderer = QuadRenderer.instantiateRenderer();\n            this._rendererIsDisposable = true;\n        }\n        this._scene = new Scene();\n        this._camera = new OrthographicCamera();\n        this._camera.position.set(0, 0, 10);\n        this._camera.left = -0.5;\n        this._camera.right = 0.5;\n        this._camera.top = 0.5;\n        this._camera.bottom = -0.5;\n        this._camera.updateProjectionMatrix();\n        if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n            let alternativeType;\n            switch (this._type) {\n                case HalfFloatType:\n                    alternativeType = this._renderer.extensions.has('EXT_color_buffer_float') ? FloatType : undefined;\n                    break;\n            }\n            if (alternativeType !== undefined) {\n                console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`);\n                this._type = alternativeType;\n            }\n            else {\n                this._supportsReadPixels = false;\n                console.warn('This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown');\n            }\n        }\n        this._quad = new Mesh(new PlaneGeometry(), this._material);\n        this._quad.geometry.computeBoundingBox();\n        this._scene.add(this._quad);\n        this._renderTarget = new WebGLRenderTarget(this.width, this.height, rtOptions);\n        this._renderTarget.texture.mapping = ((_q = options.renderTargetOptions) === null || _q === void 0 ? void 0 : _q.mapping) !== undefined ? (_r = options.renderTargetOptions) === null || _r === void 0 ? void 0 : _r.mapping : UVMapping;\n    }\n    /**\n     * Instantiates a temporary renderer\n     *\n     * @returns\n     */\n    static instantiateRenderer() {\n        const renderer = new WebGLRenderer();\n        renderer.setSize(128, 128);\n        // renderer.outputColorSpace = SRGBColorSpace\n        // renderer.toneMapping = LinearToneMapping\n        // renderer.debug.checkShaderErrors = false\n        // this._rendererIsDisposable = true\n        return renderer;\n    }\n    /**\n     * Obtains a Buffer containing the rendered texture.\n     *\n     * @throws Error if the browser cannot read pixels from this RenderTarget type.\n     * @returns a TypedArray containing RGBA values from this renderer\n     */\n    toArray() {\n        if (!this._supportsReadPixels)\n            throw new Error('Can\\'t read pixels in this browser');\n        const out = getBufferForType(this._type, this._width, this._height);\n        this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n        return out;\n    }\n    /**\n     * Performs a readPixel operation in the renderTarget\n     * and returns a DataTexture containing the read data\n     *\n     * @param options options\n     * @returns\n     */\n    toDataTexture(options) {\n        const returnValue = new DataTexture(\n        // fixed values\n        this.toArray(), this.width, this.height, RGBAFormat, this._type, \n        // user values\n        (options === null || options === void 0 ? void 0 : options.mapping) || UVMapping, (options === null || options === void 0 ? void 0 : options.wrapS) || ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.wrapT) || ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.magFilter) || LinearFilter, (options === null || options === void 0 ? void 0 : options.minFilter) || LinearFilter, (options === null || options === void 0 ? void 0 : options.anisotropy) || 1, \n        // fixed value\n        LinearSRGBColorSpace);\n        // set this afterwards, we can't set it in constructor\n        returnValue.generateMipmaps = (options === null || options === void 0 ? void 0 : options.generateMipmaps) !== undefined ? options === null || options === void 0 ? void 0 : options.generateMipmaps : false;\n        return returnValue;\n    }\n    /**\n     * If using a disposable renderer, it will dispose it.\n     */\n    disposeOnDemandRenderer() {\n        this._renderer.setRenderTarget(null);\n        if (this._rendererIsDisposable) {\n            this._renderer.dispose();\n            this._renderer.forceContextLoss();\n        }\n    }\n    /**\n     * Will dispose of **all** assets used by this renderer.\n     *\n     *\n     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n     * or are otherwise done with it.\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n     * // DO NOT dispose the renderTarget here,\n     * // it is used directly in the material\n     * result.dispose()\n     * ```\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const pmremGenerator = new PMREMGenerator( renderer );\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n     * // renderTarget can be disposed here\n     * // because it was used to generate a PMREM texture\n     * result.dispose(true)\n     * ```\n     */\n    dispose(disposeRenderTarget) {\n        this.disposeOnDemandRenderer();\n        if (disposeRenderTarget) {\n            this.renderTarget.dispose();\n        }\n        // dispose shader material texture uniforms\n        if (this.material instanceof ShaderMaterial) {\n            Object.values(this.material.uniforms).forEach(v => {\n                if (v.value instanceof Texture)\n                    v.value.dispose();\n            });\n        }\n        // dispose other material properties\n        Object.values(this.material).forEach(value => {\n            if (value instanceof Texture)\n                value.dispose();\n        });\n        this.material.dispose();\n        this._quad.geometry.dispose();\n    }\n    /**\n     * Width of the texture\n     */\n    get width() { return this._width; }\n    set width(value) {\n        this._width = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * Height of the texture\n     */\n    get height() { return this._height; }\n    set height(value) {\n        this._height = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * The renderer used\n     */\n    get renderer() { return this._renderer; }\n    /**\n     * The `WebGLRenderTarget` used.\n     */\n    get renderTarget() { return this._renderTarget; }\n    set renderTarget(value) {\n        this._renderTarget = value;\n        this._width = value.width;\n        this._height = value.height;\n        // this._type = value.texture.type\n    }\n    /**\n     * The `Material` used.\n     */\n    get material() { return this._material; }\n    /**\n     *\n     */\n    get type() { return this._type; }\n    get colorSpace() { return this._colorSpace; }\n}\n\nexport { QuadRenderer as Q };\n","/**\n * @monogrid/gainmap-js v3.1.0\n * With ❤️, by MONOGRID <rnd@monogrid.com>\n */\n\nimport { Q as QuadRenderer } from './QuadRenderer-DuOPRGA4.js';\nimport { ShaderMaterial, Vector3, NoBlending, SRGBColorSpace, LinearSRGBColorSpace, HalfFloatType, Loader, LoadingManager, Texture, UVMapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, FileLoader } from 'three';\n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapDecoderMaterial extends ShaderMaterial {\n    /**\n     *\n     * @param params\n     */\n    constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {\n        super({\n            name: 'GainMapDecoderMaterial',\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                sdr: { value: sdr },\n                gainMap: { value: gainMap },\n                gamma: { value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2]) },\n                offsetHdr: { value: new Vector3().fromArray(offsetHdr) },\n                offsetSdr: { value: new Vector3().fromArray(offsetSdr) },\n                gainMapMin: { value: new Vector3().fromArray(gainMapMin) },\n                gainMapMax: { value: new Vector3().fromArray(gainMapMax) },\n                weightFactor: {\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                }\n            },\n            blending: NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._maxDisplayBoost = maxDisplayBoost;\n        this._hdrCapacityMin = hdrCapacityMin;\n        this._hdrCapacityMax = hdrCapacityMax;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get sdr() { return this.uniforms.sdr.value; }\n    set sdr(value) { this.uniforms.sdr.value = value; }\n    get gainMap() { return this.uniforms.gainMap.value; }\n    set gainMap(value) { this.uniforms.gainMap.value = value; }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */\n    get offsetHdr() { return this.uniforms.offsetHdr.value.toArray(); }\n    set offsetHdr(value) { this.uniforms.offsetHdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */\n    get offsetSdr() { return this.uniforms.offsetSdr.value.toArray(); }\n    set offsetSdr(value) { this.uniforms.offsetSdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */\n    get gainMapMin() { return this.uniforms.gainMapMin.value.toArray(); }\n    set gainMapMin(value) { this.uniforms.gainMapMin.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */\n    get gainMapMax() { return this.uniforms.gainMapMax.value.toArray(); }\n    set gainMapMax(value) { this.uniforms.gainMapMax.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */\n    get gamma() {\n        const g = this.uniforms.gamma.value;\n        return [1 / g.x, 1 / g.y, 1 / g.z];\n    }\n    set gamma(value) {\n        const g = this.uniforms.gamma.value;\n        g.x = 1.0 / value[0];\n        g.y = 1.0 / value[1];\n        g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMin() { return this._hdrCapacityMin; }\n    set hdrCapacityMin(value) {\n        this._hdrCapacityMin = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMax() { return this._hdrCapacityMax; }\n    set hdrCapacityMax(value) {\n        this._hdrCapacityMax = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */\n    get maxDisplayBoost() { return this._maxDisplayBoost; }\n    set maxDisplayBoost(value) {\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n        this.calculateWeight();\n    }\n    calculateWeight() {\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n}\n\n/**\n * Decodes a gain map using a WebGLRenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = await decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nconst decode = (params) => {\n    const { sdr, gainMap, renderer } = params;\n    if (sdr.colorSpace !== SRGBColorSpace) {\n        console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n        sdr.colorSpace = SRGBColorSpace;\n    }\n    sdr.needsUpdate = true;\n    if (gainMap.colorSpace !== LinearSRGBColorSpace) {\n        console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n        gainMap.colorSpace = LinearSRGBColorSpace;\n    }\n    gainMap.needsUpdate = true;\n    const material = new GainMapDecoderMaterial({\n        ...params,\n        sdr,\n        gainMap\n    });\n    const quadRenderer = new QuadRenderer({\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        width: sdr.image.width,\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        height: sdr.image.height,\n        type: HalfFloatType,\n        colorSpace: LinearSRGBColorSpace,\n        material,\n        renderer,\n        renderTargetOptions: params.renderTargetOptions\n    });\n    try {\n        quadRenderer.render();\n    }\n    catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n\nclass GainMapNotFoundError extends Error {\n}\n\nclass XMPMetadataNotFoundError extends Error {\n}\n\nconst getXMLValue = (xml, tag, defaultValue) => {\n    // Check for attribute format first: tag=\"value\"\n    const attributeMatch = new RegExp(`${tag}=\"([^\"]*)\"`, 'i').exec(xml);\n    if (attributeMatch)\n        return attributeMatch[1];\n    // Check for tag format: <tag>value</tag> or <tag><rdf:li>value</rdf:li>...</tag>\n    const tagMatch = new RegExp(`<${tag}[^>]*>([\\\\s\\\\S]*?)</${tag}>`, 'i').exec(xml);\n    if (tagMatch) {\n        // Check if it contains rdf:li elements\n        const liValues = tagMatch[1].match(/<rdf:li>([^<]*)<\\/rdf:li>/g);\n        if (liValues && liValues.length === 3) {\n            return liValues.map(v => v.replace(/<\\/?rdf:li>/g, ''));\n        }\n        return tagMatch[1].trim();\n    }\n    if (defaultValue !== undefined)\n        return defaultValue;\n    throw new Error(`Can't find ${tag} in gainmap metadata`);\n};\nconst extractXMP = (input) => {\n    let str;\n    // support node test environment\n    if (typeof TextDecoder !== 'undefined')\n        str = new TextDecoder().decode(input);\n    else\n        str = input.toString();\n    let start = str.indexOf('<x:xmpmeta');\n    while (start !== -1) {\n        const end = str.indexOf('x:xmpmeta>', start);\n        const xmpBlock = str.slice(start, end + 10);\n        try {\n            const gainMapMin = getXMLValue(xmpBlock, 'hdrgm:GainMapMin', '0');\n            const gainMapMax = getXMLValue(xmpBlock, 'hdrgm:GainMapMax');\n            const gamma = getXMLValue(xmpBlock, 'hdrgm:Gamma', '1');\n            const offsetSDR = getXMLValue(xmpBlock, 'hdrgm:OffsetSDR', '0.015625');\n            const offsetHDR = getXMLValue(xmpBlock, 'hdrgm:OffsetHDR', '0.015625');\n            // These are always attributes, so we can use a simpler regex\n            const hdrCapacityMinMatch = /hdrgm:HDRCapacityMin=\"([^\"]*)\"/.exec(xmpBlock);\n            const hdrCapacityMin = hdrCapacityMinMatch ? hdrCapacityMinMatch[1] : '0';\n            const hdrCapacityMaxMatch = /hdrgm:HDRCapacityMax=\"([^\"]*)\"/.exec(xmpBlock);\n            if (!hdrCapacityMaxMatch)\n                throw new Error('Incomplete gainmap metadata');\n            const hdrCapacityMax = hdrCapacityMaxMatch[1];\n            return {\n                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n                gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n                hdrCapacityMin: parseFloat(hdrCapacityMin),\n                hdrCapacityMax: parseFloat(hdrCapacityMax)\n            };\n        }\n        catch (e) {\n            // Continue searching for another xmpmeta block if this one fails\n        }\n        start = str.indexOf('<x:xmpmeta', end);\n    }\n};\n\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */\nclass MPFExtractor {\n    constructor(options) {\n        this.options = {\n            debug: options && options.debug !== undefined ? options.debug : false,\n            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n        };\n    }\n    extract(imageArrayBuffer) {\n        return new Promise((resolve, reject) => {\n            const debug = this.options.debug;\n            const dataView = new DataView(imageArrayBuffer.buffer);\n            // If you're executing this line on a big endian machine, it'll be reversed.\n            // bigEnd further down though, refers to the endianness of the image itself.\n            if (dataView.getUint16(0) !== 0xffd8) {\n                reject(new Error('Not a valid jpeg'));\n                return;\n            }\n            const length = dataView.byteLength;\n            let offset = 2;\n            let loops = 0;\n            let marker; // APP# marker\n            while (offset < length) {\n                if (++loops > 250) {\n                    reject(new Error(`Found no marker after ${loops} loops 😵`));\n                    return;\n                }\n                if (dataView.getUint8(offset) !== 0xff) {\n                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                    return;\n                }\n                marker = dataView.getUint8(offset + 1);\n                if (debug)\n                    console.log(`Marker: ${marker.toString(16)}`);\n                if (marker === 0xe2) {\n                    if (debug)\n                        console.log('Found APP2 marker (0xffe2)');\n                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                    // Great way to visualize image information in html is using Exiftool. E.g.:\n                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                    const formatPt = offset + 4;\n                    /*\n                     *  Structure of the MP Format Identifier\n                     *\n                     *  Offset Addr.  | Code (Hex)  | Description\n                     *  +00             ff            Marker Prefix      <-- offset\n                     *  +01             e2            APP2\n                     *  +02             #n            APP2 Field Length\n                     *  +03             #n            APP2 Field Length\n                     *  +04             4d            'M'                <-- formatPt\n                     *  +05             50            'P'\n                     *  +06             46            'F'\n                     *  +07             00            NULL\n                     *                                                   <-- tiffOffset\n                     */\n                    if (dataView.getUint32(formatPt) === 0x4d504600) {\n                        // Found MPF tag, so we start dig out sub images\n                        const tiffOffset = formatPt + 4;\n                        let bigEnd; // Endianness from TIFF header\n                        // Test for TIFF validity and endianness\n                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                        if (dataView.getUint16(tiffOffset) === 0x4949) {\n                            bigEnd = false;\n                        }\n                        else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                            bigEnd = true;\n                        }\n                        else {\n                            reject(new Error('No valid endianness marker found in TIFF header'));\n                            return;\n                        }\n                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                            reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n                            return;\n                        }\n                        // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                        if (firstIFDOffset < 0x00000008) {\n                            reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n                            return;\n                        }\n                        // Move ahead to MP Index IFD\n                        // Assume we're at the first IFD, so firstIFDOffset points to\n                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                        // we fail silently here due to this assumption)\n                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                        // Extract info from MPEntries (starting after Count)\n                        const entriesStart = dirStart + 2;\n                        let numberOfImages = 0;\n                        for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n                            // Each entry is 12 Bytes long\n                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                // stored in Last 4 bytes of its 12 Byte entry.\n                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                            }\n                        }\n                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                        const images = [];\n                        for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n                            const image = {\n                                MPType: dataView.getUint32(i, !bigEnd),\n                                size: dataView.getUint32(i + 4, !bigEnd),\n                                // This offset is specified relative to the address of the MP Endian\n                                // field in the MP Header, unless the image is a First Individual Image,\n                                // in which case the value of the offset shall be NULL (0x00000000).\n                                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                start: -1,\n                                end: -1,\n                                isFII: false\n                            };\n                            if (!image.dataOffset) {\n                                // dataOffset is 0x00000000 for First Individual Image\n                                image.start = 0;\n                                image.isFII = true;\n                            }\n                            else {\n                                image.start = tiffOffset + image.dataOffset;\n                                image.isFII = false;\n                            }\n                            image.end = image.start + image.size;\n                            images.push(image);\n                        }\n                        if (this.options.extractNonFII && images.length) {\n                            const bufferBlob = new Blob([dataView]);\n                            const imgs = [];\n                            for (const image of images) {\n                                if (image.isFII && !this.options.extractFII) {\n                                    continue; // Skip FII\n                                }\n                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                                // we don't need this\n                                // const imageUrl = URL.createObjectURL(imageBlob)\n                                // image.img = document.createElement('img')\n                                // image.img.src = imageUrl\n                                imgs.push(imageBlob);\n                            }\n                            resolve(imgs);\n                        }\n                    }\n                }\n                offset += 2 + dataView.getUint16(offset + 2);\n            }\n        });\n    }\n}\n\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */\nconst extractGainmapFromJPEG = async (jpegFile) => {\n    const metadata = extractXMP(jpegFile);\n    if (!metadata)\n        throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n    const mpfExtractor = new MPFExtractor({ extractFII: true, extractNonFII: true });\n    const images = await mpfExtractor.extract(jpegFile);\n    if (images.length !== 2)\n        throw new GainMapNotFoundError('Gain map recovery image not found');\n    return {\n        sdr: new Uint8Array(await images[0].arrayBuffer()),\n        gainMap: new Uint8Array(await images[1].arrayBuffer()),\n        metadata\n    };\n};\n\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */\nconst getHTMLImageFromBlob = (blob) => {\n    return new Promise((resolve, reject) => {\n        const img = document.createElement('img');\n        img.onload = () => { resolve(img); };\n        img.onerror = (e) => { reject(e); };\n        img.src = URL.createObjectURL(blob);\n    });\n};\n\nclass LoaderBase extends Loader {\n    /**\n     *\n     * @param renderer\n     * @param manager\n     */\n    constructor(renderer, manager) {\n        super(manager);\n        if (renderer)\n            this._renderer = renderer;\n        this._internalLoadingManager = new LoadingManager();\n    }\n    /**\n     * Specify the renderer to use when rendering the gain map\n     *\n     * @param renderer\n     * @returns\n     */\n    setRenderer(renderer) {\n        this._renderer = renderer;\n        return this;\n    }\n    /**\n     * Specify the renderTarget options to use when rendering the gain map\n     *\n     * @param options\n     * @returns\n     */\n    setRenderTargetOptions(options) {\n        this._renderTargetOptions = options;\n        return this;\n    }\n    /**\n     * @private\n     * @returns\n     */\n    prepareQuadRenderer() {\n        if (!this._renderer)\n            console.warn('WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n        // temporary values\n        const material = new GainMapDecoderMaterial({\n            gainMapMax: [1, 1, 1],\n            gainMapMin: [0, 0, 0],\n            gamma: [1, 1, 1],\n            offsetHdr: [1, 1, 1],\n            offsetSdr: [1, 1, 1],\n            hdrCapacityMax: 1,\n            hdrCapacityMin: 0,\n            maxDisplayBoost: 1,\n            gainMap: new Texture(),\n            sdr: new Texture()\n        });\n        return new QuadRenderer({\n            width: 16,\n            height: 16,\n            type: HalfFloatType,\n            colorSpace: LinearSRGBColorSpace,\n            material,\n            renderer: this._renderer,\n            renderTargetOptions: this._renderTargetOptions\n        });\n    }\n    /**\n   * @private\n   * @param quadRenderer\n   * @param metadata\n   * @param sdrBuffer\n   * @param gainMapBuffer\n   */\n    async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        // this is optional, will render a black gain-map if not present\n        const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], { type: 'image/jpeg' }) : undefined;\n        const sdrBlob = new Blob([sdrBuffer], { type: 'image/jpeg' });\n        let sdrImage;\n        let gainMapImage;\n        let needsFlip = false;\n        if (typeof createImageBitmap === 'undefined') {\n            const res = await Promise.all([\n                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                getHTMLImageFromBlob(sdrBlob)\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n            needsFlip = true;\n        }\n        else {\n            const res = await Promise.all([\n                gainMapBlob ? createImageBitmap(gainMapBlob, { imageOrientation: 'flipY' }) : Promise.resolve(undefined),\n                createImageBitmap(sdrBlob, { imageOrientation: 'flipY' })\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n        }\n        const gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);\n        gainMap.flipY = needsFlip;\n        gainMap.needsUpdate = true;\n        const sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);\n        sdr.flipY = needsFlip;\n        sdr.needsUpdate = true;\n        quadRenderer.width = sdrImage.width;\n        quadRenderer.height = sdrImage.height;\n        quadRenderer.material.gainMap = gainMap;\n        quadRenderer.material.sdr = sdr;\n        quadRenderer.material.gainMapMin = metadata.gainMapMin;\n        quadRenderer.material.gainMapMax = metadata.gainMapMax;\n        quadRenderer.material.offsetHdr = metadata.offsetHdr;\n        quadRenderer.material.offsetSdr = metadata.offsetSdr;\n        quadRenderer.material.gamma = metadata.gamma;\n        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n        quadRenderer.material.needsUpdate = true;\n        quadRenderer.render();\n    }\n}\n\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass GainMapLoader extends LoaderBase {\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        let sdr;\n        let gainMap;\n        let metadata;\n        const loadCheck = async () => {\n            if (sdr && gainMap && metadata) {\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\n                }\n                catch (error) {\n                    this.manager.itemError(sdrUrl);\n                    this.manager.itemError(gainMapUrl);\n                    this.manager.itemError(metadataUrl);\n                    if (typeof onError === 'function')\n                        onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === 'function')\n                    onLoad(quadRenderer);\n                this.manager.itemEnd(sdrUrl);\n                this.manager.itemEnd(gainMapUrl);\n                this.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n            }\n        };\n        let sdrLengthComputable = true;\n        let sdrTotal = 0;\n        let sdrLoaded = 0;\n        let gainMapLengthComputable = true;\n        let gainMapTotal = 0;\n        let gainMapLoaded = 0;\n        let metadataLengthComputable = true;\n        let metadataTotal = 0;\n        let metadataLoaded = 0;\n        const progressHandler = () => {\n            if (typeof onProgress === 'function') {\n                const total = sdrTotal + gainMapTotal + metadataTotal;\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                onProgress(new ProgressEvent('progress', { lengthComputable, loaded, total }));\n            }\n        };\n        this.manager.itemStart(sdrUrl);\n        this.manager.itemStart(gainMapUrl);\n        this.manager.itemStart(metadataUrl);\n        const sdrLoader = new FileLoader(this._internalLoadingManager);\n        sdrLoader.setResponseType('arraybuffer');\n        sdrLoader.setRequestHeader(this.requestHeader);\n        sdrLoader.setPath(this.path);\n        sdrLoader.setWithCredentials(this.withCredentials);\n        sdrLoader.load(sdrUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid sdr buffer');\n            sdr = buffer;\n            await loadCheck();\n        }, (e) => {\n            sdrLengthComputable = e.lengthComputable;\n            sdrLoaded = e.loaded;\n            sdrTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(sdrUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const gainMapLoader = new FileLoader(this._internalLoadingManager);\n        gainMapLoader.setResponseType('arraybuffer');\n        gainMapLoader.setRequestHeader(this.requestHeader);\n        gainMapLoader.setPath(this.path);\n        gainMapLoader.setWithCredentials(this.withCredentials);\n        gainMapLoader.load(gainMapUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid gainmap buffer');\n            gainMap = buffer;\n            await loadCheck();\n        }, (e) => {\n            gainMapLengthComputable = e.lengthComputable;\n            gainMapLoaded = e.loaded;\n            gainMapTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(gainMapUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const metadataLoader = new FileLoader(this._internalLoadingManager);\n        // metadataLoader.setResponseType('json')\n        metadataLoader.setRequestHeader(this.requestHeader);\n        metadataLoader.setPath(this.path);\n        metadataLoader.setWithCredentials(this.withCredentials);\n        metadataLoader.load(metadataUrl, async (json) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof json !== 'string')\n                throw new Error('Invalid metadata string');\n            // TODO: implement check on JSON file and remove this eslint disable\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metadata = JSON.parse(json);\n            await loadCheck();\n        }, (e) => {\n            metadataLengthComputable = e.lengthComputable;\n            metadataLoaded = e.loaded;\n            metadataTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(metadataUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass HDRJPGLoader extends LoaderBase {\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load(url, onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        const loader = new FileLoader(this._internalLoadingManager);\n        loader.setResponseType('arraybuffer');\n        loader.setRequestHeader(this.requestHeader);\n        loader.setPath(this.path);\n        loader.setWithCredentials(this.withCredentials);\n        this.manager.itemStart(url);\n        loader.load(url, async (jpeg) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof jpeg === 'string')\n                throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n            const jpegBuffer = new Uint8Array(jpeg);\n            let sdrJPEG;\n            let gainMapJPEG;\n            let metadata;\n            try {\n                const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n            }\n            catch (e) {\n                // render the SDR version if this is not a gainmap\n                if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                    metadata = {\n                        gainMapMin: [0, 0, 0],\n                        gainMapMax: [1, 1, 1],\n                        gamma: [1, 1, 1],\n                        hdrCapacityMin: 0,\n                        hdrCapacityMax: 1,\n                        offsetHdr: [0, 0, 0],\n                        offsetSdr: [0, 0, 0]\n                    };\n                    sdrJPEG = jpegBuffer;\n                }\n                else {\n                    throw e;\n                }\n            }\n            // solves #16\n            try {\n                await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);\n            }\n            catch (error) {\n                this.manager.itemError(url);\n                if (typeof onError === 'function')\n                    onError(error);\n                quadRenderer.disposeOnDemandRenderer();\n                return;\n            }\n            if (typeof onLoad === 'function')\n                onLoad(quadRenderer);\n            this.manager.itemEnd(url);\n            quadRenderer.disposeOnDemandRenderer();\n        }, onProgress, (error) => {\n            this.manager.itemError(url);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\nexport { GainMapDecoderMaterial, GainMapLoader, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, MPFExtractor, QuadRenderer, decode, extractGainmapFromJPEG, extractXMP };\n","const presetsObj = {\n  apartment: 'lebombo_1k.hdr',\n  city: 'potsdamer_platz_1k.hdr',\n  dawn: 'kiara_1_dawn_1k.hdr',\n  forest: 'forest_slope_1k.hdr',\n  lobby: 'st_fagans_interior_1k.hdr',\n  night: 'dikhololo_night_1k.hdr',\n  park: 'rooitou_park_1k.hdr',\n  studio: 'studio_small_03_1k.hdr',\n  sunset: 'venice_sunset_1k.hdr',\n  warehouse: 'empty_warehouse_01_1k.hdr'\n};\n\nexport { presetsObj };\n","/**\n * Sets `BufferAttribute.updateRange` since r159.\n */\nconst setUpdateRange = (attribute, updateRange) => {\n  if ('updateRanges' in attribute) {\n    // r159\n    // @ts-ignore\n    attribute.updateRanges[0] = updateRange;\n  } else {\n    attribute.updateRange = updateRange;\n  }\n};\nconst LinearEncoding = 3000;\nconst sRGBEncoding = 3001;\n\n/**\n * TextureEncoding was deprecated in r152, and removed in r162.\n */\n\nexport { LinearEncoding, sRGBEncoding, setUpdateRange };\n","import { useThree, useLoader } from '@react-three/fiber';\nimport { CubeReflectionMapping, EquirectangularReflectionMapping, CubeTextureLoader } from 'three';\nimport { RGBELoader, EXRLoader } from 'three-stdlib';\nimport { HDRJPGLoader, GainMapLoader } from '@monogrid/gainmap-js';\nimport { presetsObj } from '../helpers/environment-assets.js';\nimport { sRGBEncoding, LinearEncoding } from '../helpers/deprecated.js';\nimport { useLayoutEffect } from 'react';\n\nconst CUBEMAP_ROOT = 'https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/';\nconst isArray = arr => Array.isArray(arr);\nconst defaultFiles = ['/px.png', '/nx.png', '/py.png', '/ny.png', '/pz.png', '/nz.png'];\nfunction useEnvironment({\n  files = defaultFiles,\n  path = '',\n  preset = undefined,\n  encoding = undefined,\n  extensions\n} = {}) {\n  let loader = null;\n  let multiFile = false;\n  if (preset) {\n    validatePreset(preset);\n    files = presetsObj[preset];\n    path = CUBEMAP_ROOT;\n  }\n\n  // Everything else\n  multiFile = isArray(files);\n  const {\n    extension,\n    isCubemap\n  } = getExtension(files);\n  loader = getLoader(extension);\n  if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);\n  const gl = useThree(state => state.gl);\n  useLayoutEffect(() => {\n    // Only required for gainmap\n    if (extension !== 'webp' && extension !== 'jpg' && extension !== 'jpeg') return;\n    function clearGainmapTexture() {\n      useLoader.clear(\n      // @ts-expect-error\n      loader, multiFile ? [files] : files);\n    }\n    gl.domElement.addEventListener('webglcontextlost', clearGainmapTexture, {\n      once: true\n    });\n  }, [files, gl.domElement]);\n  const loaderResult = useLoader(\n  // @ts-expect-error\n  loader, multiFile ? [files] : files, loader => {\n    // Gainmap requires a renderer\n    if (extension === 'webp' || extension === 'jpg' || extension === 'jpeg') {\n      loader.setRenderer(gl);\n    }\n    loader.setPath == null || loader.setPath(path);\n    if (extensions) extensions(loader);\n  });\n  let texture = multiFile ?\n  // @ts-ignore\n  loaderResult[0] : loaderResult;\n  if (extension === 'jpg' || extension === 'jpeg' || extension === 'webp') {\n    var _renderTarget;\n    texture = (_renderTarget = texture.renderTarget) == null ? void 0 : _renderTarget.texture;\n  }\n  texture.mapping = isCubemap ? CubeReflectionMapping : EquirectangularReflectionMapping;\n  if ('colorSpace' in texture) texture.colorSpace = (encoding !== null && encoding !== void 0 ? encoding : isCubemap) ? 'srgb' : 'srgb-linear';else texture.encoding = (encoding !== null && encoding !== void 0 ? encoding : isCubemap) ? sRGBEncoding : LinearEncoding;\n  return texture;\n}\nconst preloadDefaultOptions = {\n  files: defaultFiles,\n  path: '',\n  preset: undefined,\n  extensions: undefined\n};\nuseEnvironment.preload = preloadOptions => {\n  const options = {\n    ...preloadDefaultOptions,\n    ...preloadOptions\n  };\n  let {\n    files,\n    path = ''\n  } = options;\n  const {\n    preset,\n    extensions\n  } = options;\n  if (preset) {\n    validatePreset(preset);\n    files = presetsObj[preset];\n    path = CUBEMAP_ROOT;\n  }\n  const {\n    extension\n  } = getExtension(files);\n  if (extension === 'webp' || extension === 'jpg' || extension === 'jpeg') {\n    throw new Error('useEnvironment: Preloading gainmaps is not supported');\n  }\n  const loader = getLoader(extension);\n  if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);\n  useLoader.preload(\n  // @ts-expect-error\n  loader, isArray(files) ? [files] : files, loader => {\n    loader.setPath == null || loader.setPath(path);\n    if (extensions) extensions(loader);\n  });\n};\nconst clearDefaultOptins = {\n  files: defaultFiles,\n  preset: undefined\n};\nuseEnvironment.clear = clearOptions => {\n  const options = {\n    ...clearDefaultOptins,\n    ...clearOptions\n  };\n  let {\n    files\n  } = options;\n  const {\n    preset\n  } = options;\n  if (preset) {\n    validatePreset(preset);\n    files = presetsObj[preset];\n  }\n  const {\n    extension\n  } = getExtension(files);\n  const loader = getLoader(extension);\n  if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);\n  useLoader.clear(\n  // @ts-expect-error\n  loader, isArray(files) ? [files] : files);\n};\nfunction validatePreset(preset) {\n  if (!(preset in presetsObj)) throw new Error('Preset must be one of: ' + Object.keys(presetsObj).join(', '));\n}\nfunction getExtension(files) {\n  var _firstEntry$split$pop;\n  const isCubemap = isArray(files) && files.length === 6;\n  const isGainmap = isArray(files) && files.length === 3 && files.some(file => file.endsWith('json'));\n  const firstEntry = isArray(files) ? files[0] : files;\n\n  // Everything else\n  const extension = isCubemap ? 'cube' : isGainmap ? 'webp' : firstEntry.startsWith('data:application/exr') ? 'exr' : firstEntry.startsWith('data:application/hdr') ? 'hdr' : firstEntry.startsWith('data:image/jpeg') ? 'jpg' : (_firstEntry$split$pop = firstEntry.split('.').pop()) == null || (_firstEntry$split$pop = _firstEntry$split$pop.split('?')) == null || (_firstEntry$split$pop = _firstEntry$split$pop.shift()) == null ? void 0 : _firstEntry$split$pop.toLowerCase();\n  return {\n    extension,\n    isCubemap,\n    isGainmap\n  };\n}\nfunction getLoader(extension) {\n  const loader = extension === 'cube' ? CubeTextureLoader : extension === 'hdr' ? RGBELoader : extension === 'exr' ? EXRLoader : extension === 'jpg' || extension === 'jpeg' ? HDRJPGLoader : extension === 'webp' ? GainMapLoader : null;\n  return loader;\n}\n\nexport { useEnvironment };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useThree, useFrame, createPortal, applyProps, extend } from '@react-three/fiber';\nimport { Scene, WebGLCubeRenderTarget, HalfFloatType } from 'three';\nimport { GroundProjectedEnv } from 'three-stdlib';\nimport { useEnvironment } from './useEnvironment.js';\n\nconst isRef = obj => obj.current && obj.current.isScene;\nconst resolveScene = scene => isRef(scene) ? scene.current : scene;\nfunction setEnvProps(background, scene, defaultScene, texture, sceneProps = {}) {\n  var _target$backgroundRot, _target$backgroundRot2, _target$environmentRo, _target$environmentRo2;\n  // defaults\n  sceneProps = {\n    backgroundBlurriness: 0,\n    backgroundIntensity: 1,\n    backgroundRotation: [0, 0, 0],\n    environmentIntensity: 1,\n    environmentRotation: [0, 0, 0],\n    ...sceneProps\n  };\n  const target = resolveScene(scene || defaultScene);\n  const oldbg = target.background;\n  const oldenv = target.environment;\n  const oldSceneProps = {\n    // @ts-ignore\n    backgroundBlurriness: target.backgroundBlurriness,\n    // @ts-ignore\n    backgroundIntensity: target.backgroundIntensity,\n    // @ts-ignore\n    backgroundRotation: (_target$backgroundRot = (_target$backgroundRot2 = target.backgroundRotation) == null || _target$backgroundRot2.clone == null ? void 0 : _target$backgroundRot2.clone()) !== null && _target$backgroundRot !== void 0 ? _target$backgroundRot : [0, 0, 0],\n    // @ts-ignore\n    environmentIntensity: target.environmentIntensity,\n    // @ts-ignore\n    environmentRotation: (_target$environmentRo = (_target$environmentRo2 = target.environmentRotation) == null || _target$environmentRo2.clone == null ? void 0 : _target$environmentRo2.clone()) !== null && _target$environmentRo !== void 0 ? _target$environmentRo : [0, 0, 0]\n  };\n  if (background !== 'only') target.environment = texture;\n  if (background) target.background = texture;\n  applyProps(target, sceneProps);\n  return () => {\n    if (background !== 'only') target.environment = oldenv;\n    if (background) target.background = oldbg;\n    applyProps(target, oldSceneProps);\n  };\n}\nfunction EnvironmentMap({\n  scene,\n  background = false,\n  map,\n  ...config\n}) {\n  const defaultScene = useThree(state => state.scene);\n  React.useLayoutEffect(() => {\n    if (map) return setEnvProps(background, scene, defaultScene, map, config);\n  });\n  return null;\n}\nfunction EnvironmentCube({\n  background = false,\n  scene,\n  blur,\n  backgroundBlurriness,\n  backgroundIntensity,\n  backgroundRotation,\n  environmentIntensity,\n  environmentRotation,\n  ...rest\n}) {\n  const texture = useEnvironment(rest);\n  const defaultScene = useThree(state => state.scene);\n  React.useLayoutEffect(() => {\n    return setEnvProps(background, scene, defaultScene, texture, {\n      backgroundBlurriness: blur !== null && blur !== void 0 ? blur : backgroundBlurriness,\n      backgroundIntensity,\n      backgroundRotation,\n      environmentIntensity,\n      environmentRotation\n    });\n  });\n  React.useEffect(() => {\n    return () => {\n      texture.dispose();\n    };\n  }, [texture]);\n  return null;\n}\nfunction EnvironmentPortal({\n  children,\n  near = 0.1,\n  far = 1000,\n  resolution = 256,\n  frames = 1,\n  map,\n  background = false,\n  blur,\n  backgroundBlurriness,\n  backgroundIntensity,\n  backgroundRotation,\n  environmentIntensity,\n  environmentRotation,\n  scene,\n  files,\n  path,\n  preset = undefined,\n  extensions\n}) {\n  const gl = useThree(state => state.gl);\n  const defaultScene = useThree(state => state.scene);\n  const camera = React.useRef(null);\n  const [virtualScene] = React.useState(() => new Scene());\n  const fbo = React.useMemo(() => {\n    const fbo = new WebGLCubeRenderTarget(resolution);\n    fbo.texture.type = HalfFloatType;\n    return fbo;\n  }, [resolution]);\n  React.useEffect(() => {\n    return () => {\n      fbo.dispose();\n    };\n  }, [fbo]);\n  React.useLayoutEffect(() => {\n    if (frames === 1) {\n      const autoClear = gl.autoClear;\n      gl.autoClear = true;\n      camera.current.update(gl, virtualScene);\n      gl.autoClear = autoClear;\n    }\n    return setEnvProps(background, scene, defaultScene, fbo.texture, {\n      backgroundBlurriness: blur !== null && blur !== void 0 ? blur : backgroundBlurriness,\n      backgroundIntensity,\n      backgroundRotation,\n      environmentIntensity,\n      environmentRotation\n    });\n  }, [children, virtualScene, fbo.texture, scene, defaultScene, background, frames, gl]);\n  let count = 1;\n  useFrame(() => {\n    if (frames === Infinity || count < frames) {\n      const autoClear = gl.autoClear;\n      gl.autoClear = true;\n      camera.current.update(gl, virtualScene);\n      gl.autoClear = autoClear;\n      count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal(/*#__PURE__*/React.createElement(React.Fragment, null, children, /*#__PURE__*/React.createElement(\"cubeCamera\", {\n    ref: camera,\n    args: [near, far, fbo]\n  }), files || preset ? /*#__PURE__*/React.createElement(EnvironmentCube, {\n    background: true,\n    files: files,\n    preset: preset,\n    path: path,\n    extensions: extensions\n  }) : map ? /*#__PURE__*/React.createElement(EnvironmentMap, {\n    background: true,\n    map: map,\n    extensions: extensions\n  }) : null), virtualScene));\n}\nfunction EnvironmentGround(props) {\n  var _props$ground, _props$ground2, _scale, _props$ground3;\n  const textureDefault = useEnvironment(props);\n  const texture = props.map || textureDefault;\n  React.useMemo(() => extend({\n    GroundProjectedEnvImpl: GroundProjectedEnv\n  }), []);\n  React.useEffect(() => {\n    return () => {\n      textureDefault.dispose();\n    };\n  }, [textureDefault]);\n  const args = React.useMemo(() => [texture], [texture]);\n  const height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;\n  const radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;\n  const scale = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1000;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(EnvironmentMap, _extends({}, props, {\n    map: texture\n  })), /*#__PURE__*/React.createElement(\"groundProjectedEnvImpl\", {\n    args: args,\n    scale: scale,\n    height: height,\n    radius: radius\n  }));\n}\nfunction Environment(props) {\n  return props.ground ? /*#__PURE__*/React.createElement(EnvironmentGround, props) : props.map ? /*#__PURE__*/React.createElement(EnvironmentMap, props) : props.children ? /*#__PURE__*/React.createElement(EnvironmentPortal, props) : /*#__PURE__*/React.createElement(EnvironmentCube, props);\n}\n\nexport { Environment, EnvironmentCube, EnvironmentMap, EnvironmentPortal };\n","let webGLAvailable, webGL2Available;\nfunction isWebGLAvailable() {\n  var _a;\n  if (webGLAvailable !== void 0)\n    return webGLAvailable;\n  try {\n    let gl;\n    const canvas = document.createElement(\"canvas\");\n    webGLAvailable = !!(window.WebGLRenderingContext && (gl = canvas.getContext(\"webgl\")));\n    if (gl)\n      (_a = gl.getExtension(\"WEBGL_lose_context\")) == null ? void 0 : _a.loseContext();\n    return webGLAvailable;\n  } catch (e) {\n    return webGLAvailable = false;\n  }\n}\nfunction isWebGL2Available() {\n  var _a;\n  if (webGL2Available !== void 0)\n    return webGL2Available;\n  try {\n    let gl;\n    const canvas = document.createElement(\"canvas\");\n    webGL2Available = !!(window.WebGL2RenderingContext && (gl = canvas.getContext(\"webgl2\")));\n    if (gl)\n      (_a = gl.getExtension(\"WEBGL_lose_context\")) == null ? void 0 : _a.loseContext();\n    return webGL2Available;\n  } catch (e) {\n    return webGL2Available = false;\n  }\n}\nfunction getWebGLErrorMessage() {\n  return getErrorMessage(1);\n}\nfunction getWebGL2ErrorMessage() {\n  return getErrorMessage(2);\n}\nfunction getErrorMessage(version) {\n  const names = {\n    1: \"WebGL\",\n    2: \"WebGL 2\"\n  };\n  const contexts = {\n    1: window.WebGLRenderingContext,\n    2: window.WebGL2RenderingContext\n  };\n  const element = document.createElement(\"div\");\n  element.id = \"webglmessage\";\n  element.style.fontFamily = \"monospace\";\n  element.style.fontSize = \"13px\";\n  element.style.fontWeight = \"normal\";\n  element.style.textAlign = \"center\";\n  element.style.background = \"#fff\";\n  element.style.color = \"#000\";\n  element.style.padding = \"1.5em\";\n  element.style.width = \"400px\";\n  element.style.margin = \"5em auto 0\";\n  let message = 'Your $0 does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000\">$1</a>';\n  if (contexts[version]) {\n    message = message.replace(\"$0\", \"graphics card\");\n  } else {\n    message = message.replace(\"$0\", \"browser\");\n  }\n  message = message.replace(\"$1\", names[version]);\n  element.innerHTML = message;\n  return element;\n}\nexport {\n  getErrorMessage,\n  getWebGL2ErrorMessage,\n  getWebGLErrorMessage,\n  isWebGL2Available,\n  isWebGLAvailable\n};\n//# sourceMappingURL=WebGL.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { NoToneMapping, HalfFloatType } from \"three\";\nimport React, { createContext, forwardRef, useMemo, useEffect, useRef, useLayoutEffect, useImperativeHandle } from \"react\";\nimport { useThree, useFrame } from \"@react-three/fiber\";\nimport { EffectComposer as EffectComposer$1, RenderPass, NormalPass, DepthDownsamplingPass, Effect, EffectPass, EffectAttribute, Pass } from \"postprocessing\";\nimport { isWebGL2Available } from \"three-stdlib\";\nconst EffectComposerContext = createContext(null);\nconst isConvolution = (effect) => (effect.getAttributes() & EffectAttribute.CONVOLUTION) === EffectAttribute.CONVOLUTION;\nconst EffectComposer = React.memo(\n  forwardRef(\n    ({\n      children,\n      camera: _camera,\n      scene: _scene,\n      resolutionScale,\n      enabled = true,\n      renderPriority = 1,\n      autoClear = true,\n      depthBuffer,\n      enableNormalPass,\n      stencilBuffer,\n      multisampling = 8,\n      frameBufferType = HalfFloatType\n    }, ref) => {\n      const { gl, scene: defaultScene, camera: defaultCamera, size } = useThree();\n      const scene = _scene || defaultScene;\n      const camera = _camera || defaultCamera;\n      const [composer, normalPass, downSamplingPass] = useMemo(() => {\n        const webGL2Available = isWebGL2Available();\n        const effectComposer = new EffectComposer$1(gl, {\n          depthBuffer,\n          stencilBuffer,\n          multisampling: multisampling > 0 && webGL2Available ? multisampling : 0,\n          frameBufferType\n        });\n        effectComposer.addPass(new RenderPass(scene, camera));\n        let downSamplingPass2 = null;\n        let normalPass2 = null;\n        if (enableNormalPass) {\n          normalPass2 = new NormalPass(scene, camera);\n          normalPass2.enabled = false;\n          effectComposer.addPass(normalPass2);\n          if (resolutionScale !== void 0 && webGL2Available) {\n            downSamplingPass2 = new DepthDownsamplingPass({ normalBuffer: normalPass2.texture, resolutionScale });\n            downSamplingPass2.enabled = false;\n            effectComposer.addPass(downSamplingPass2);\n          }\n        }\n        return [effectComposer, normalPass2, downSamplingPass2];\n      }, [\n        camera,\n        gl,\n        depthBuffer,\n        stencilBuffer,\n        multisampling,\n        frameBufferType,\n        scene,\n        enableNormalPass,\n        resolutionScale\n      ]);\n      useEffect(() => composer == null ? void 0 : composer.setSize(size.width, size.height), [composer, size]);\n      useFrame(\n        (_, delta) => {\n          if (enabled) {\n            const currentAutoClear = gl.autoClear;\n            gl.autoClear = autoClear;\n            if (stencilBuffer && !autoClear)\n              gl.clearStencil();\n            composer.render(delta);\n            gl.autoClear = currentAutoClear;\n          }\n        },\n        enabled ? renderPriority : 0\n      );\n      const group = useRef(null);\n      useLayoutEffect(() => {\n        var _a;\n        const passes = [];\n        const groupInstance = (_a = group.current) == null ? void 0 : _a.__r3f;\n        if (groupInstance && composer) {\n          const children2 = groupInstance.objects;\n          for (let i = 0; i < children2.length; i++) {\n            const child = children2[i];\n            if (child instanceof Effect) {\n              const effects = [child];\n              if (!isConvolution(child)) {\n                let next = null;\n                while ((next = children2[i + 1]) instanceof Effect) {\n                  if (isConvolution(next))\n                    break;\n                  effects.push(next);\n                  i++;\n                }\n              }\n              const pass = new EffectPass(camera, ...effects);\n              passes.push(pass);\n            } else if (child instanceof Pass) {\n              passes.push(child);\n            }\n          }\n          for (const pass of passes)\n            composer == null ? void 0 : composer.addPass(pass);\n          if (normalPass)\n            normalPass.enabled = true;\n          if (downSamplingPass)\n            downSamplingPass.enabled = true;\n        }\n        return () => {\n          for (const pass of passes)\n            composer == null ? void 0 : composer.removePass(pass);\n          if (normalPass)\n            normalPass.enabled = false;\n          if (downSamplingPass)\n            downSamplingPass.enabled = false;\n        };\n      }, [composer, children, camera, normalPass, downSamplingPass]);\n      useEffect(() => {\n        const currentTonemapping = gl.toneMapping;\n        gl.toneMapping = NoToneMapping;\n        return () => {\n          gl.toneMapping = currentTonemapping;\n        };\n      }, [gl]);\n      const state = useMemo(\n        () => ({ composer, normalPass, downSamplingPass, resolutionScale, camera, scene }),\n        [composer, normalPass, downSamplingPass, resolutionScale, camera, scene]\n      );\n      useImperativeHandle(ref, () => composer, [composer]);\n      return /* @__PURE__ */ jsx(EffectComposerContext.Provider, { value: state, children: /* @__PURE__ */ jsx(\"group\", { ref: group, children }) });\n    }\n  )\n);\nexport {\n  EffectComposer,\n  EffectComposerContext\n};\n//# sourceMappingURL=EffectComposer.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { createContext, useState, useMemo, useRef, useContext, useEffect } from \"react\";\nconst selectionContext = createContext(null);\nfunction Selection({ children, enabled = true }) {\n  const [selected, select] = useState([]);\n  const value = useMemo(() => ({ selected, select, enabled }), [selected, select, enabled]);\n  return /* @__PURE__ */ jsx(selectionContext.Provider, { value, children });\n}\nfunction Select({ enabled = false, children, ...props }) {\n  const group = useRef(null);\n  const api = useContext(selectionContext);\n  useEffect(() => {\n    if (api && enabled) {\n      let changed = false;\n      const current = [];\n      group.current.traverse((o) => {\n        o.type === \"Mesh\" && current.push(o);\n        if (api.selected.indexOf(o) === -1)\n          changed = true;\n      });\n      if (changed) {\n        api.select((state) => [...state, ...current]);\n        return () => {\n          api.select((state) => state.filter((selected) => !current.includes(selected)));\n        };\n      }\n    }\n  }, [enabled, children, api]);\n  return /* @__PURE__ */ jsx(\"group\", { ref: group, ...props, children });\n}\nexport {\n  Select,\n  Selection,\n  selectionContext\n};\n//# sourceMappingURL=Selection.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport React from \"react\";\nimport * as THREE from \"three\";\nimport { extend, useThree } from \"@react-three/fiber\";\nconst resolveRef = (ref) => typeof ref === \"object\" && ref != null && \"current\" in ref ? ref.current : ref;\nlet i = 0;\nconst components = /* @__PURE__ */ new WeakMap();\nconst wrapEffect = (effect, defaults) => /* @__PURE__ */ React.forwardRef(function Effect({ blendFunction = defaults == null ? void 0 : defaults.blendFunction, opacity = defaults == null ? void 0 : defaults.opacity, ...props }, ref) {\n  let Component = components.get(effect);\n  if (!Component) {\n    const key = `@react-three/postprocessing/${effect.name}-${i++}`;\n    extend({ [key]: effect });\n    components.set(effect, Component = key);\n  }\n  const camera = useThree((state) => state.camera);\n  const args = React.useMemo(\n    () => {\n      var _a, _b;\n      return [...(_a = defaults == null ? void 0 : defaults.args) != null ? _a : [], ...(_b = props.args) != null ? _b : [{ ...defaults, ...props }]];\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [JSON.stringify(props)]\n  );\n  return /* @__PURE__ */ jsx(\n    Component,\n    {\n      camera,\n      \"blendMode-blendFunction\": blendFunction,\n      \"blendMode-opacity-value\": opacity,\n      ...props,\n      ref,\n      args\n    }\n  );\n});\nconst useVector2 = (props, key) => {\n  const value = props[key];\n  return React.useMemo(() => {\n    if (typeof value === \"number\")\n      return new THREE.Vector2(value, value);\n    else if (value)\n      return new THREE.Vector2(...value);\n    else\n      return new THREE.Vector2();\n  }, [value]);\n};\nexport {\n  resolveRef,\n  useVector2,\n  wrapEffect\n};\n//# sourceMappingURL=util.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { OutlineEffect } from \"postprocessing\";\nimport { forwardRef, useContext, useMemo, useEffect, useRef } from \"react\";\nimport { useThree } from \"@react-three/fiber\";\nimport { EffectComposerContext } from \"../EffectComposer.js\";\nimport { selectionContext } from \"../Selection.js\";\nimport { resolveRef } from \"../util.js\";\nconst Outline = forwardRef(function Outline2({\n  selection = [],\n  selectionLayer = 10,\n  blendFunction,\n  patternTexture,\n  edgeStrength,\n  pulseSpeed,\n  visibleEdgeColor,\n  hiddenEdgeColor,\n  width,\n  height,\n  kernelSize,\n  blur,\n  xRay,\n  ...props\n}, forwardRef2) {\n  const invalidate = useThree((state) => state.invalidate);\n  const { scene, camera } = useContext(EffectComposerContext);\n  const effect = useMemo(\n    () => new OutlineEffect(scene, camera, {\n      blendFunction,\n      patternTexture,\n      edgeStrength,\n      pulseSpeed,\n      visibleEdgeColor,\n      hiddenEdgeColor,\n      width,\n      height,\n      kernelSize,\n      blur,\n      xRay,\n      ...props\n    }),\n    // NOTE: `props` is an unstable reference, so we can't memoize it\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      blendFunction,\n      blur,\n      camera,\n      edgeStrength,\n      height,\n      hiddenEdgeColor,\n      kernelSize,\n      patternTexture,\n      pulseSpeed,\n      scene,\n      visibleEdgeColor,\n      width,\n      xRay\n    ]\n  );\n  const api = useContext(selectionContext);\n  useEffect(() => {\n    if (!api && selection) {\n      effect.selection.set(\n        Array.isArray(selection) ? selection.map(resolveRef) : [resolveRef(selection)]\n      );\n      invalidate();\n      return () => {\n        effect.selection.clear();\n        invalidate();\n      };\n    }\n  }, [effect, selection, api, invalidate]);\n  useEffect(() => {\n    effect.selectionLayer = selectionLayer;\n    invalidate();\n  }, [effect, invalidate, selectionLayer]);\n  useRef();\n  useEffect(() => {\n    var _a;\n    if (api && api.enabled) {\n      if ((_a = api.selected) == null ? void 0 : _a.length) {\n        effect.selection.set(api.selected);\n        invalidate();\n        return () => {\n          effect.selection.clear();\n          invalidate();\n        };\n      }\n    }\n  }, [api, effect.selection, invalidate]);\n  useEffect(() => {\n    return () => {\n      effect.dispose();\n    };\n  }, [effect]);\n  return /* @__PURE__ */ jsx(\"primitive\", { ref: forwardRef2, object: effect });\n});\nexport {\n  Outline\n};\n//# sourceMappingURL=Outline.js.map\n","import { ToneMappingEffect } from \"postprocessing\";\nimport { wrapEffect } from \"../util.js\";\nconst ToneMapping = wrapEffect(ToneMappingEffect);\nexport {\n  ToneMapping\n};\n//# sourceMappingURL=ToneMapping.js.map\n","\"use client\";\n\nimport React from \"react\";\nimport { useMemo, useRef, useState, useCallback } from \"react\";\nimport { Canvas, ThreeEvent, useThree } from \"@react-three/fiber\";\nimport { Environment, OrbitControls, useGLTF } from \"@react-three/drei\";\nimport {\n  ACESFilmicToneMapping,\n  NoToneMapping,\n  HalfFloatType,\n  Mesh,\n  Group,\n  Vector3,\n  Box3,\n  SRGBColorSpace,\n  LinearSRGBColorSpace\n} from \"three\";\nimport {\n  EffectComposer,\n  Outline,\n  ToneMapping as ToneMappingEffect\n} from \"@react-three/postprocessing\";\nimport { BlendFunction, ToneMappingMode } from \"postprocessing\";\n\nfunction HouseModel({\n  onSelectMesh,\n  onLoadingChange\n}: {\n  onSelectMesh: (m: Mesh) => void;\n  onLoadingChange: (loading: boolean) => void;\n}) {\n  const { scene } = useGLTF(\"/models/house/house.glb\");\n\n  React.useEffect(() => {\n    onLoadingChange(false); // 모델 로딩 완료\n  }, [scene, onLoadingChange]);\n\n  // primitive에 이벤트를 달면 하위 mesh에서 버블업됨\n  const handlePointerDown = useCallback(\n    (e: ThreeEvent<MouseEvent>) => {\n      e.stopPropagation();\n      const obj = e.object as Mesh;\n      if ((obj as any).isMesh) onSelectMesh(obj);\n    },\n    [onSelectMesh]\n  );\n  return <primitive object={scene} onPointerDown={handlePointerDown} />;\n}\n\nuseGLTF.preload(\"/models/house/house.glb\");\n\nfunction CenterCameraOnModel({\n  groupRef,\n  controlsRef\n}: {\n  groupRef: React.RefObject<Group>;\n  controlsRef: React.RefObject<any>;\n}) {\n  const { camera } = useThree();\n\n  React.useEffect(() => {\n    const group = groupRef.current;\n    if (!group) return;\n\n    const box = new Box3().setFromObject(group);\n    const center = new Vector3();\n    box.getCenter(center);\n\n    const size = new Vector3();\n    box.getSize(size);\n    const distance = Math.max(size.x, size.y, size.z) * 1;\n\n    camera.position.set(center.x, center.y + distance, center.z);\n    camera.lookAt(center);\n    camera.updateProjectionMatrix();\n\n    const orbit = controlsRef.current;\n    if (orbit?.target) {\n      orbit.target.copy(center);\n      orbit.update?.();\n    }\n  }, [groupRef, camera, controlsRef]);\n\n  return null;\n}\n\nexport default function HouseViewerRepro() {\n  const [useRendererToneMapping, setUseRendererToneMapping] = useState(true); // 문제 재현 ON\n  const [useHalfFloat, setUseHalfFloat] = useState(false); // 8bit→HDR로 전환\n  const [useComposerToneMapping, setUseComposerToneMapping] = useState(false); // 수정 파이프라인\n  const [alwaysOnComposer, setAlwaysOnComposer] = useState(false); // EffectComposer ON/OFF 토글\n  const [selectedMeshes, setSelectedMeshes] = useState<Mesh[]>([]);\n  const [isLoading, setIsLoading] = useState(true); // 로딩 상태\n\n  const groupRef = useRef<Group>(null);\n  const controlsRef = useRef<any>(null);\n\n  const toggleSelect = useCallback((mesh: Mesh) => {\n    setSelectedMeshes(prev => {\n      const exists = prev.includes(mesh);\n      if (exists) return prev.filter(m => m !== mesh);\n      return [...prev, mesh];\n    });\n  }, []);\n\n  const handleLoadingChange = useCallback((loading: boolean) => {\n    setIsLoading(loading);\n  }, []);\n\n  const glProps = useMemo(\n    () => ({\n      outputColorSpace: LinearSRGBColorSpace,\n      // 문제 재현을 위해 기본은 ACES 톤매핑 ON\n      toneMapping: useRendererToneMapping\n        ? ACESFilmicToneMapping\n        : NoToneMapping\n    }),\n    [useRendererToneMapping]\n  );\n\n  return (\n    <div\n      style={{\n        position: \"relative\",\n        width: \"100%\",\n        height: \"100vh\",\n        background: \"#111\"\n      }}\n    >\n      <style>\n        {`\n          @keyframes spin {\n            0% { transform: rotate(0deg); }\n            100% { transform: rotate(360deg); }\n          }\n        `}\n      </style>\n      {/* 작은 실험용 UI */}\n      <div\n        style={{\n          position: \"absolute\",\n          top: 12,\n          right: 12,\n          zIndex: 10,\n          background: \"rgba(0,0,0,0.6)\",\n          color: \"white\",\n          padding: \"10px 12px\",\n          borderRadius: 8,\n          fontSize: 12,\n          lineHeight: 1.4,\n          userSelect: \"none\"\n        }}\n      >\n        <div style={{ fontWeight: 700, marginBottom: 6 }}>Repro toggles</div>\n        <label style={{ display: \"block\" }}>\n          <input\n            type=\"checkbox\"\n            checked={alwaysOnComposer}\n            onChange={e => setAlwaysOnComposer(e.target.checked)}\n          />{\" \"}\n          EffectComposer Always ON\n        </label>\n        <label style={{ display: \"block\" }}>\n          <input\n            type=\"checkbox\"\n            checked={useRendererToneMapping}\n            onChange={e => setUseRendererToneMapping(e.target.checked)}\n          />{\" \"}\n          Renderer ToneMapping (ACES) ON\n        </label>\n        <label style={{ display: \"block\" }}>\n          <input\n            type=\"checkbox\"\n            checked={useComposerToneMapping}\n            onChange={e => setUseComposerToneMapping(e.target.checked)}\n          />{\" \"}\n          Add ToneMappingEffect at end\n        </label>\n        <label style={{ display: \"block\" }}>\n          <input\n            type=\"checkbox\"\n            checked={useHalfFloat}\n            onChange={e => setUseHalfFloat(e.target.checked)}\n          />{\" \"}\n          Composer HalfFloat (HDR buffer)\n        </label>\n        <div style={{ marginTop: 8, opacity: 0.8 }}>\n          - Click meshes to toggle selection.\n          <br />- Selected meshes get Outline (Blend: SCREEN).\n        </div>\n      </div>\n\n      {/* 로딩 오버레이 */}\n      {isLoading && (\n        <div\n          style={{\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            background: \"rgba(0,0,0,0.4)\",\n            display: \"flex\",\n            alignItems: \"center\",\n            justifyContent: \"center\",\n            zIndex: 20,\n            color: \"white\",\n            fontSize: 18,\n            fontWeight: 500\n          }}\n        >\n          <div style={{ textAlign: \"center\" }}>\n            <div\n              style={{\n                width: 40,\n                height: 40,\n                border: \"3px solid rgba(255,255,255,0.2)\",\n                borderTop: \"3px solid white\",\n                borderRadius: \"50%\",\n                animation: \"spin 1s linear infinite\",\n                margin: \"0 auto 16px\"\n              }}\n            />\n            <div>3D 모델 로딩 중...</div>\n          </div>\n        </div>\n      )}\n\n      <Canvas\n        gl={glProps}\n        camera={{\n          fov: 50\n        }}\n      >\n        <Environment files=\"/models/house/environment.hdr\" background />\n\n        <group ref={groupRef} position={[0, 0, 0]} scale={[5, 5, 5]}>\n          <HouseModel\n            onSelectMesh={toggleSelect}\n            onLoadingChange={handleLoadingChange}\n          />\n        </group>\n        <CenterCameraOnModel groupRef={groupRef} controlsRef={controlsRef} />\n        <OrbitControls makeDefault ref={controlsRef} />\n\n        {(alwaysOnComposer || selectedMeshes.length > 0) && (\n          <EffectComposer\n            multisampling={8}\n            autoClear={false}\n            // 기본은 8bit(LDR) → 밝기 차이를 보기 쉬움\n            // HalfFloat로 바꾸면 HDR 품질↑ (현상 완화 비교 가능)\n            frameBufferType={useHalfFloat ? HalfFloatType : undefined}\n          >\n            {selectedMeshes.length > 0 ? (\n              <Outline\n                // 기본 합성은 SCREEN → 밝게 덧씌워져 \"발광\"처럼 보임\n                blendFunction={BlendFunction.SCREEN}\n                selection={selectedMeshes}\n                edgeStrength={5}\n                pulseSpeed={0}\n                blur={false}\n                xRay\n                visibleEdgeColor={0x66b2fe}\n                hiddenEdgeColor={0x66b2fe}\n                width={500}\n                height={500}\n              />\n            ) : (\n              <></>\n            )}\n\n            {/* 수정 파이프라인 비교: 렌더러 톤매핑 OFF일 때 여기에 추가 */}\n            {useComposerToneMapping ? (\n              <ToneMappingEffect mode={ToneMappingMode.ACES_FILMIC} />\n            ) : (\n              <></>\n            )}\n          </EffectComposer>\n        )}\n      </Canvas>\n    </div>\n  );\n}\n","import React from \"react\";\nimport HouseViewerRepro from \"../components/HouseViewer\";\n\nexport default function PostprocessingDemo() {\n  return <HouseViewerRepro />;\n}\n"],"names":["GroundProjectedEnv","constructor","texture","options","_a","_b","isCubeMap","def","isCubeTexture","cubeSize","image","width","_lodMax","Math","floor","log2","_cubeSize","pow","fragmentShader","max","join","uniforms","map","value","height","radius","super","vertexShader","side","this","material","RGBELoader","manager","type","parse","buffer","rgbe_error","rgbe_error_code","msg","Error","fgets","buffer2","lineLimit","consume","p","pos","i","len","s","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","length","slice","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","e","scale","RGBEByteToRGBHalf","toHalfFloat","min","byteArray","Uint8Array","rgbe_header_info","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","line","match","charAt","parseFloat","parseInt","RGBE_ReadHeader","w","h","image_rgba_data","w2","h2","scanline_width","data_rgba","offset","ptr_end","rgbeStart","scanline_buffer","num_scanlines","count","ptr","isEncodedRun","byteValue","set","l","off","RGBE_ReadPixels_RLE","data","numElements","floatArray","Float32Array","j","halfArray","setDataType","load","url","onLoad","onProgress","onError","texData","colorSpace","encoding","minFilter","magFilter","generateMipmaps","flipY","u8","u16","u32","Uint32Array","fleb","fdeb","clim","freb","eb","start","b","r","fl","revfl","fd","rev","x","hMap","cd","mb","co","le","rvb","sv","r_1","v","m","flt","fdt","a","bits","d","o","bits16","shft","slc","n","inflt","dat","buf","st","sl","noBuf","noSt","cbuf","bl","nbuf","final","f","bt","lm","dm","lbt","dbt","tbts","t","flrm","fdrm","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","lt","dt","lms","dms","lpos","sym","add","dsym","end","et","zlv","unzlibSync","out","td","TextDecoder","decode","stream","hasColorSpace","EXRLoader","USHORT_RANGE","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","logBase","getBitsReturn","lc","getBits","nBits","uInt8Array2","inOffset","parseUint8Array","hufTableBuffer","Array","hufUnpackEncTable","inDataView","ni","im","iM","hcode","zerun","nc","hufCanonicalCodeTable","hufLength","code","hufCode","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","UInt16","Int16","ref","wdec14Return","wdec14","ls","hs","ai","as","bs","wdec16","bb","aa","wav2Decode","nx","ox","ny","oy","mx","p2","w14","i00","i01","i10","i11","py","ey","oy1","oy2","ox1","ox2","px","ex","p01","p11","p10","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","hdec","lit","hufClearDecTable","hdecod","pl","plOffset","hufBuildDecTable","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","hufDecode","predictor","source","interleaveScalar","t1","t2","stop","decodeRunLength","size","reader","DataView","getInt8","push","getUint8","unRleAC","currAcComp","acBuffer","halfZigBlock","acValue","dctComp","unZigZag","src","dst","decodeFloat16","dctInverse","cos","g","alpha","beta","theta","row","rowPtr","column","csc709Inverse","y","cb","cr","convertToHalf","idx","toLinear","float","sign","abs","uncompressRAW","info","array","uncompressRLE","compressed","viewer","rawBuffer","tmpBuffer","uncompressZIP","uncompressPIZ","scanlineBlockSize","channels","bitmap","outBufferEnd","pizChannelData","lines","minNonZero","parseUint16","maxNonZero","parseUint8","lut","maxValue","k","reverseLutFromBitmap","nData","applyLut","tmpOffset2","cp","uncompressPXR","sz","tmpBufferEnd","writePtr","pixel","uncompressDWA","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","EXRHeader","compression","channelRules","ruleSize","name","parseNullTerminatedString","index","Int8Array","channelData","channel","decoded","pixelType","pLinear","cscSet","offset2","rule","zlibInfo","dcBuffer","rleBuffer","rowOffsets","chan","rowPtrs","dataView","numFullBlocksX","numBlocksX","ceil","numBlocksY","leftoverX","leftoverY","currDcComp","dctData","rowBlock","comp2","blocky","maxY","maxX","blockx","fill","type2","y2","setUint16","offset3","x2","halfRow","comp","getUint16","setFloat32","lossyDctDecode","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","parseInt32","Int32","getInt32","Uint32","getUint32","Uint8","int","prototype","Number","getBigInt64","parseFloat32","getFloat32","decodeFloat32","binary","exponent","fraction","NaN","Infinity","Uint16","parseFloat16","parseValue","parseFixedLengthString","startOffset","xSampling","ySampling","parseChlist","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseChromaticities","parseCompression","xMin","yMin","xMax","yMax","parseBox2i","parseLineOrder","parseV2f","parseV3f","parseRational","parseTimecode","bufferDataView","uInt8Array","EXRHeader2","spec","singleTile","longName","deepFormat","multiPart","keepReading","attributeName","attributeType","attributeValue","console","warn","error","parseHeader","EXRDecoder","outputType","EXRDecoder2","dataWindow","bytesPerLine","inputSize","uncompress","getter","blockCount","outputChannels","setupDecoder","tmpOffset","channelOffsets","R","G","B","A","Y","scanlineBlockIdx","line_y","true_y","channelID","cOff","outIndex","getBufferForType","Uint8ClampedArray","Int16Array","Int32Array","_canReadPixelsResult","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","_rendererIsDisposable","_supportsReadPixels","render","_renderer","setRenderTarget","_renderTarget","_scene","_camera","_width","_height","_type","_colorSpace","rtOptions","depthBuffer","stencilBuffer","anisotropy","undefined","renderTargetOptions","samples","wrapS","wrapT","_material","renderer","instantiateRenderer","position","left","right","top","bottom","updateProjectionMatrix","camera","testRT","mesh","color","readRenderTargetPixels","dispose","geometry","canReadPixels","alternativeType","extensions","has","_quad","computeBoundingBox","mapping","static","WebGLRenderer","setSize","toArray","toDataTexture","returnValue","disposeOnDemandRenderer","forceContextLoss","disposeRenderTarget","renderTarget","Object","values","forEach","GainMapDecoderMaterial","offsetHdr","offsetSdr","gainMapMin","gainMapMax","maxDisplayBoost","hdrCapacityMin","hdrCapacityMax","sdr","gainMap","fromArray","weightFactor","blending","depthTest","depthWrite","_maxDisplayBoost","_hdrCapacityMin","_hdrCapacityMax","needsUpdate","uniformsNeedUpdate","z","calculateWeight","val","GainMapNotFoundError","XMPMetadataNotFoundError","getXMLValue","xml","tag","defaultValue","attributeMatch","RegExp","exec","tagMatch","liValues","replace","trim","MPFExtractor","debug","extractFII","extractNonFII","extract","imageArrayBuffer","Promise","resolve","reject","marker","loops","toString","log","formatPt","tiffOffset","bigEnd","firstIFDOffset","dirStart","entriesStart","numberOfImages","MPImageListValPt","images","MPType","dataOffset","dependantImages","isFII","bufferBlob","Blob","imgs","imageBlob","extractGainmapFromJPEG","async","jpegFile","metadata","input","str","xmpBlock","offsetSDR","offsetHDR","hdrCapacityMinMatch","hdrCapacityMaxMatch","isArray","extractXMP","mpfExtractor","arrayBuffer","getHTMLImageFromBlob","blob","img","document","createElement","onload","onerror","URL","createObjectURL","LoaderBase","_internalLoadingManager","setRenderer","setRenderTargetOptions","_renderTargetOptions","prepareQuadRenderer","quadRenderer","sdrBuffer","gainMapBuffer","gainMapBlob","sdrBlob","sdrImage","gainMapImage","needsFlip","createImageBitmap","res","all","imageOrientation","ImageData","GainMapLoader","sdrUrl","gainMapUrl","metadataUrl","loadCheck","itemError","itemEnd","sdrLengthComputable","sdrTotal","sdrLoaded","gainMapLengthComputable","gainMapTotal","gainMapLoaded","metadataLengthComputable","metadataTotal","metadataLoaded","progressHandler","ProgressEvent","lengthComputable","loaded","total","itemStart","sdrLoader","setResponseType","setRequestHeader","requestHeader","setPath","path","setWithCredentials","withCredentials","gainMapLoader","metadataLoader","json","JSON","HDRJPGLoader","loader","jpeg","jpegBuffer","sdrJPEG","gainMapJPEG","extractionResult","presetsObj","apartment","city","dawn","forest","lobby","night","park","studio","sunset","warehouse","LinearEncoding","sRGBEncoding","CUBEMAP_ROOT","arr","defaultFiles","useEnvironment","files","preset","multiFile","validatePreset","extension","isCubemap","getExtension","getLoader","gl","state","useLayoutEffect","domElement","addEventListener","clear","once","loaderResult","preloadDefaultOptions","preload","preloadOptions","clearDefaultOptins","keys","_firstEntry$split$pop","isGainmap","some","file","endsWith","firstEntry","startsWith","split","pop","shift","toLowerCase","clearOptions","resolveScene","scene","isRef","obj","current","isScene","setEnvProps","background","defaultScene","sceneProps","_target$backgroundRot","_target$backgroundRot2","_target$environmentRo","_target$environmentRo2","backgroundBlurriness","backgroundIntensity","backgroundRotation","environmentIntensity","environmentRotation","target","oldbg","oldenv","environment","oldSceneProps","clone","EnvironmentMap","config","EnvironmentCube","blur","rest","EnvironmentPortal","children","near","far","resolution","frames","virtualScene","fbo","autoClear","update","args","EnvironmentGround","props","_props$ground","_props$ground2","_scale","_props$ground3","textureDefault","GroundProjectedEnvImpl","ground","Environment","webGL2Available","isWebGL2Available","canvas","window","WebGL2RenderingContext","getContext","loseContext","EffectComposerContext","createContext","isConvolution","effect","getAttributes","CONVOLUTION","EffectComposer","forwardRef","resolutionScale","enabled","renderPriority","enableNormalPass","multisampling","frameBufferType","defaultCamera","composer","normalPass","downSamplingPass","useMemo","effectComposer","addPass","downSamplingPass2","normalPass2","normalBuffer","useEffect","_","delta","currentAutoClear","clearStencil","group","useRef","passes","groupInstance","__r3f","children2","objects","child","effects","next","pass","removePass","currentTonemapping","toneMapping","useImperativeHandle","jsx","Provider","selectionContext","resolveRef","components","WeakMap","Outline","selection","selectionLayer","blendFunction","patternTexture","edgeStrength","pulseSpeed","visibleEdgeColor","hiddenEdgeColor","kernelSize","xRay","forwardRef2","invalidate","useContext","api","selected","object","ToneMapping","defaults","opacity","Component","get","key","stringify","HouseModel","onSelectMesh","onLoadingChange","useGLTF","React","handlePointerDown","useCallback","stopPropagation","isMesh","onPointerDown","CenterCameraOnModel","groupRef","controlsRef","useThree","box","Box3","setFromObject","center","Vector3","getCenter","getSize","distance","lookAt","orbit","copy","_orbit$update","HouseViewerRepro","useRendererToneMapping","setUseRendererToneMapping","useState","useHalfFloat","setUseHalfFloat","useComposerToneMapping","setUseComposerToneMapping","alwaysOnComposer","setAlwaysOnComposer","selectedMeshes","setSelectedMeshes","isLoading","setIsLoading","toggleSelect","prev","includes","filter","handleLoadingChange","loading","glProps","outputColorSpace","LinearSRGBColorSpace","ACESFilmicToneMapping","NoToneMapping","style","zIndex","padding","borderRadius","fontSize","lineHeight","userSelect","fontWeight","marginBottom","display","checked","onChange","marginTop","alignItems","justifyContent","textAlign","border","borderTop","animation","margin","Canvas","fov","OrbitControls","makeDefault","HalfFloatType","BlendFunction","SCREEN","ToneMappingEffect","mode","ToneMappingMode","ACES_FILMIC","PostprocessingDemo"],"sourceRoot":""}